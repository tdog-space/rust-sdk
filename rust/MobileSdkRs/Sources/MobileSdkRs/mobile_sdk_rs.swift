// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(mobile_sdk_rsFFI)
import mobile_sdk_rsFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_mobile_sdk_rs_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_mobile_sdk_rs_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureMobileSdkRsInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol AsyncHttpClient: AnyObject, Sendable {
    
    func httpClient(request: HttpRequest) async throws  -> HttpResponse
    
}
open class AsyncHttpClientImpl: AsyncHttpClient, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_asynchttpclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_asynchttpclient(pointer, $0) }
    }

    

    
open func httpClient(request: HttpRequest)async throws  -> HttpResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_asynchttpclient_http_client(
                    self.uniffiClonePointer(),
                    FfiConverterTypeHttpRequest_lower(request)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeHttpResponse_lift,
            errorHandler: FfiConverterTypeHttpClientError_lift
        )
}
    

}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceAsyncHttpClient {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceAsyncHttpClient] = [UniffiVTableCallbackInterfaceAsyncHttpClient(
        httpClient: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> HttpResponse in
                guard let uniffiObj = try? FfiConverterTypeAsyncHttpClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.httpClient(
                     request: try FfiConverterTypeHttpRequest_lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: HttpResponse) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeHttpResponse_lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeHttpClientError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeAsyncHttpClient.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface AsyncHttpClient: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitAsyncHttpClient() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_asynchttpclient(UniffiCallbackInterfaceAsyncHttpClient.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAsyncHttpClient: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<AsyncHttpClient>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AsyncHttpClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AsyncHttpClient {
        return AsyncHttpClientImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AsyncHttpClient) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AsyncHttpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AsyncHttpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAsyncHttpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> AsyncHttpClient {
    return try FfiConverterTypeAsyncHttpClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAsyncHttpClient_lower(_ value: AsyncHttpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAsyncHttpClient.lower(value)
}






public protocol CborIntegerProtocol: AnyObject, Sendable {
    
    func lowerBytes()  -> UInt64
    
    func toText()  -> String
    
    func upperBytes()  -> UInt64
    
}
open class CborInteger: CborIntegerProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_cborinteger(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_cborinteger(pointer, $0) }
    }

    

    
open func lowerBytes() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_cborinteger_lower_bytes(self.uniffiClonePointer(),$0
    )
})
}
    
open func toText() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_cborinteger_to_text(self.uniffiClonePointer(),$0
    )
})
}
    
open func upperBytes() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_cborinteger_upper_bytes(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCborInteger: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CborInteger

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CborInteger {
        return CborInteger(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CborInteger) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CborInteger {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CborInteger, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCborInteger_lift(_ pointer: UnsafeMutableRawPointer) throws -> CborInteger {
    return try FfiConverterTypeCborInteger.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCborInteger_lower(_ value: CborInteger) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCborInteger.lower(value)
}






public protocol CborTagProtocol: AnyObject, Sendable {
    
    func id()  -> UInt64
    
    func value()  -> CborValue
    
}
open class CborTag: CborTagProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_cbortag(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_cbortag(pointer, $0) }
    }

    

    
open func id() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_cbortag_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func value() -> CborValue  {
    return try!  FfiConverterTypeCborValue_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_cbortag_value(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCborTag: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CborTag

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CborTag {
        return CborTag(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CborTag) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CborTag {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CborTag, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCborTag_lift(_ pointer: UnsafeMutableRawPointer) throws -> CborTag {
    return try FfiConverterTypeCborTag.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCborTag_lower(_ value: CborTag) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCborTag.lower(value)
}






public protocol ClientProtocol: AnyObject, Sendable {
    
}
open class Client: ClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_client(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_client(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}






public protocol CredentialIssuerMetadataProtocol: AnyObject, Sendable {
    
}
open class CredentialIssuerMetadata: CredentialIssuerMetadataProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_credentialissuermetadata(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_credentialissuermetadata(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentialIssuerMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CredentialIssuerMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CredentialIssuerMetadata {
        return CredentialIssuerMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CredentialIssuerMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialIssuerMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CredentialIssuerMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialIssuerMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> CredentialIssuerMetadata {
    return try FfiConverterTypeCredentialIssuerMetadata.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialIssuerMetadata_lower(_ value: CredentialIssuerMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCredentialIssuerMetadata.lower(value)
}






public protocol CredentialRequestProtocol: AnyObject, Sendable {
    
}
open class CredentialRequest: CredentialRequestProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_credentialrequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_credentialrequest(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentialRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CredentialRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CredentialRequest {
        return CredentialRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CredentialRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CredentialRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> CredentialRequest {
    return try FfiConverterTypeCredentialRequest.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialRequest_lower(_ value: CredentialRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCredentialRequest.lower(value)
}






public protocol Crypto: AnyObject, Sendable {
    
    func p256Verify(certificateDer: Data, payload: Data, signature: Data)  -> VerificationResult
    
}
open class CryptoImpl: Crypto, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_crypto(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_crypto(pointer, $0) }
    }

    

    
open func p256Verify(certificateDer: Data, payload: Data, signature: Data) -> VerificationResult  {
    return try!  FfiConverterTypeVerificationResult_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_crypto_p256_verify(self.uniffiClonePointer(),
        FfiConverterData.lower(certificateDer),
        FfiConverterData.lower(payload),
        FfiConverterData.lower(signature),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceCrypto {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceCrypto] = [UniffiVTableCallbackInterfaceCrypto(
        p256Verify: { (
            uniffiHandle: UInt64,
            certificateDer: RustBuffer,
            payload: RustBuffer,
            signature: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> VerificationResult in
                guard let uniffiObj = try? FfiConverterTypeCrypto.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.p256Verify(
                     certificateDer: try FfiConverterData.lift(certificateDer),
                     payload: try FfiConverterData.lift(payload),
                     signature: try FfiConverterData.lift(signature)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeVerificationResult_lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeCrypto.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Crypto: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitCrypto() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_crypto(UniffiCallbackInterfaceCrypto.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCrypto: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<Crypto>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Crypto

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Crypto {
        return CryptoImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Crypto) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Crypto {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Crypto, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCrypto_lift(_ pointer: UnsafeMutableRawPointer) throws -> Crypto {
    return try FfiConverterTypeCrypto.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCrypto_lower(_ value: Crypto) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCrypto.lower(value)
}






/**
 * Utility functions for cryptographic curves
 */
public protocol CryptoCurveUtilsProtocol: AnyObject, Sendable {
    
    /**
     * Returns null if the original signature encoding is not recognized.
     */
    func ensureRawFixedWidthSignatureEncoding(bytes: Data)  -> Data?
    
}
/**
 * Utility functions for cryptographic curves
 */
open class CryptoCurveUtils: CryptoCurveUtilsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_cryptocurveutils(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_cryptocurveutils(pointer, $0) }
    }

    
    /**
     * Utils for the secp256r1 (aka P-256) curve.
     */
public static func secp256r1() -> CryptoCurveUtils  {
    return try!  FfiConverterTypeCryptoCurveUtils_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_cryptocurveutils_secp256r1($0
    )
})
}
    

    
    /**
     * Returns null if the original signature encoding is not recognized.
     */
open func ensureRawFixedWidthSignatureEncoding(bytes: Data) -> Data?  {
    return try!  FfiConverterOptionData.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_cryptocurveutils_ensure_raw_fixed_width_signature_encoding(self.uniffiClonePointer(),
        FfiConverterData.lower(bytes),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCryptoCurveUtils: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = CryptoCurveUtils

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> CryptoCurveUtils {
        return CryptoCurveUtils(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: CryptoCurveUtils) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CryptoCurveUtils {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: CryptoCurveUtils, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCryptoCurveUtils_lift(_ pointer: UnsafeMutableRawPointer) throws -> CryptoCurveUtils {
    return try FfiConverterTypeCryptoCurveUtils.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCryptoCurveUtils_lower(_ value: CryptoCurveUtils) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCryptoCurveUtils.lower(value)
}






public protocol CwtProtocol: AnyObject, Sendable {
    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
    func claims()  -> [String: CborValue]
    
    /**
     * The VdcCollection ID for this credential.
     */
    func id()  -> Uuid
    
    /**
     * Return the key alias for the creden tial
     */
    func keyAlias()  -> KeyAlias?
    
    func type()  -> CredentialType
    
    func verify(crypto: Crypto) async throws 
    
}
open class Cwt: CwtProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_cwt(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_cwt(pointer, $0) }
    }

    
public static func newFromBase10(payload: String)throws  -> Cwt  {
    return try  FfiConverterTypeCwt_lift(try rustCallWithError(FfiConverterTypeCwtError_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_cwt_new_from_base10(
        FfiConverterString.lower(payload),$0
    )
})
}
    

    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
open func claims() -> [String: CborValue]  {
    return try!  FfiConverterDictionaryStringTypeCborValue.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_cwt_claims(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The VdcCollection ID for this credential.
     */
open func id() -> Uuid  {
    return try!  FfiConverterTypeUuid_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_cwt_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the key alias for the creden tial
     */
open func keyAlias() -> KeyAlias?  {
    return try!  FfiConverterOptionTypeKeyAlias.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_cwt_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    
open func type() -> CredentialType  {
    return try!  FfiConverterTypeCredentialType_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_cwt_type(self.uniffiClonePointer(),$0
    )
})
}
    
open func verify(crypto: Crypto)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_cwt_verify(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCrypto_lower(crypto)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeCwtError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCwt: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Cwt

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Cwt {
        return Cwt(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Cwt) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cwt {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Cwt, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCwt_lift(_ pointer: UnsafeMutableRawPointer) throws -> Cwt {
    return try FfiConverterTypeCwt.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCwt_lower(_ value: Cwt) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCwt.lower(value)
}






public protocol DelegatedVerifierProtocol: AnyObject, Sendable {
    
    func pollVerificationStatus(url: String) async throws  -> DelegatedVerifierStatusResponse
    
    /**
     * Initialize a delegated verification request.
     *
     * This method will respond with a uniffi::Record object that contains the
     * `auth_query` to be presented via QR code to the holder, and a `uri` to
     * check the status of the presentation from the delegated verifier.
     *
     * Provide the `uri` to the [Verifier::poll_verification_status] method to
     * check the status of the presentation.
     */
    func requestDelegatedVerification(url: String) async throws  -> DelegateInitializationResponse
    
}
open class DelegatedVerifier: DelegatedVerifierProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_delegatedverifier(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_delegatedverifier(pointer, $0) }
    }

    
public static func newClient(baseUrl: Url)async throws  -> DelegatedVerifier  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_constructor_delegatedverifier_new_client(FfiConverterTypeUrl_lower(baseUrl)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeDelegatedVerifier_lift,
            errorHandler: FfiConverterTypeOid4vpVerifierError_lift
        )
}
    

    
open func pollVerificationStatus(url: String)async throws  -> DelegatedVerifierStatusResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_delegatedverifier_poll_verification_status(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeDelegatedVerifierStatusResponse_lift,
            errorHandler: FfiConverterTypeOid4vpVerifierError_lift
        )
}
    
    /**
     * Initialize a delegated verification request.
     *
     * This method will respond with a uniffi::Record object that contains the
     * `auth_query` to be presented via QR code to the holder, and a `uri` to
     * check the status of the presentation from the delegated verifier.
     *
     * Provide the `uri` to the [Verifier::poll_verification_status] method to
     * check the status of the presentation.
     */
open func requestDelegatedVerification(url: String)async throws  -> DelegateInitializationResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_delegatedverifier_request_delegated_verification(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeDelegateInitializationResponse_lift,
            errorHandler: FfiConverterTypeOid4vpVerifierError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDelegatedVerifier: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DelegatedVerifier

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DelegatedVerifier {
        return DelegatedVerifier(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DelegatedVerifier) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DelegatedVerifier {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DelegatedVerifier, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDelegatedVerifier_lift(_ pointer: UnsafeMutableRawPointer) throws -> DelegatedVerifier {
    return try FfiConverterTypeDelegatedVerifier.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDelegatedVerifier_lower(_ value: DelegatedVerifier) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDelegatedVerifier.lower(value)
}






public protocol DidMethodUtilsProtocol: AnyObject, Sendable {
    
    func didFromJwk(jwk: String) throws  -> String
    
    func vmFromJwk(jwk: String) async throws  -> String
    
}
open class DidMethodUtils: DidMethodUtilsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_didmethodutils(self.pointer, $0) }
    }
public convenience init(method: DidMethod) {
    let pointer =
        try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_didmethodutils_new(
        FfiConverterTypeDidMethod_lower(method),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_didmethodutils(pointer, $0) }
    }

    

    
open func didFromJwk(jwk: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeDidError_lift) {
    uniffi_mobile_sdk_rs_fn_method_didmethodutils_did_from_jwk(self.uniffiClonePointer(),
        FfiConverterString.lower(jwk),$0
    )
})
}
    
open func vmFromJwk(jwk: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_didmethodutils_vm_from_jwk(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(jwk)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeDidError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDidMethodUtils: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DidMethodUtils

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DidMethodUtils {
        return DidMethodUtils(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DidMethodUtils) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DidMethodUtils {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DidMethodUtils, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDidMethodUtils_lift(_ pointer: UnsafeMutableRawPointer) throws -> DidMethodUtils {
    return try FfiConverterTypeDidMethodUtils.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDidMethodUtils_lower(_ value: DidMethodUtils) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDidMethodUtils.lower(value)
}






public protocol GrantsProtocol: AnyObject, Sendable {
    
}
open class Grants: GrantsProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_grants(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_grants(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGrants: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Grants

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Grants {
        return Grants(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Grants) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Grants {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Grants, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGrants_lift(_ pointer: UnsafeMutableRawPointer) throws -> Grants {
    return try FfiConverterTypeGrants.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGrants_lower(_ value: Grants) -> UnsafeMutableRawPointer {
    return FfiConverterTypeGrants.lower(value)
}






/**
 * A Holder is an entity that possesses one or more Verifiable Credentials.
 * The Holder is typically the subject of the credentials, but not always.
 * The Holder has the ability to generate Verifiable Presentations from
 * these credentials and share them with Verifiers.
 */
public protocol HolderProtocol: AnyObject, Sendable {
    
    /**
     * Given an authorization request URL, return a permission request,
     * which provides a list of requested credentials and requested fields
     * that align with the presentation definition of the request.
     *
     * This will fetch the presentation definition from the verifier.
     */
    func authorizationRequest(req: AuthRequest) async throws  -> PermissionRequest
    
    func submitPermissionResponse(response: PermissionResponse) async throws  -> Url?
    
}
/**
 * A Holder is an entity that possesses one or more Verifiable Credentials.
 * The Holder is typically the subject of the credentials, but not always.
 * The Holder has the ability to generate Verifiable Presentations from
 * these credentials and share them with Verifiers.
 */
open class Holder: HolderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_holder(self.pointer, $0) }
    }
    /**
     * Uses VDC collection to retrieve the credentials for a given presentation definition.
     */
public convenience init(vdcCollection: VdcCollection, trustedDids: [String], signer: PresentationSigner, contextMap: [String: String]?)async throws  {
    let pointer =
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_constructor_holder_new(FfiConverterTypeVdcCollection_lower(vdcCollection),FfiConverterSequenceString.lower(trustedDids),FfiConverterCallbackInterfacePresentationSigner_lower(signer),FfiConverterOptionDictionaryStringString.lower(contextMap)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeHolder_lift,
            errorHandler: FfiConverterTypeOID4VPError_lift
        )
        
        .uniffiClonePointer()
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_holder(pointer, $0) }
    }

    
    /**
     * Construct a new holder with provided credentials
     * instead of a VDC collection.
     *
     * This constructor will use the provided credentials for the presentation,
     * instead of searching for credentials in the VDC collection.
     */
public static func newWithCredentials(providedCredentials: [ParsedCredential], trustedDids: [String], signer: PresentationSigner, contextMap: [String: String]?)async throws  -> Holder  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_constructor_holder_new_with_credentials(FfiConverterSequenceTypeParsedCredential.lower(providedCredentials),FfiConverterSequenceString.lower(trustedDids),FfiConverterCallbackInterfacePresentationSigner_lower(signer),FfiConverterOptionDictionaryStringString.lower(contextMap)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeHolder_lift,
            errorHandler: FfiConverterTypeOID4VPError_lift
        )
}
    

    
    /**
     * Given an authorization request URL, return a permission request,
     * which provides a list of requested credentials and requested fields
     * that align with the presentation definition of the request.
     *
     * This will fetch the presentation definition from the verifier.
     */
open func authorizationRequest(req: AuthRequest)async throws  -> PermissionRequest  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_holder_authorization_request(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAuthRequest_lower(req)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypePermissionRequest_lift,
            errorHandler: FfiConverterTypeOID4VPError_lift
        )
}
    
open func submitPermissionResponse(response: PermissionResponse)async throws  -> Url?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_holder_submit_permission_response(
                    self.uniffiClonePointer(),
                    FfiConverterTypePermissionResponse_lower(response)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeUrl.lift,
            errorHandler: FfiConverterTypeOID4VPError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHolder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Holder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Holder {
        return Holder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Holder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Holder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Holder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHolder_lift(_ pointer: UnsafeMutableRawPointer) throws -> Holder {
    return try FfiConverterTypeHolder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHolder_lower(_ value: Holder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHolder.lower(value)
}






/**
 * Http client wrapper type that could either be a synchronous or asynchronous
 * external (Kotlin, Swift, etc) client implementation, receveid as a dynamic
 * trait implementation reference (`Arc<dyn (As|S)yncHttpClient`).
 *
 * `Arc` is wrapped with `IArc` to facilitate trait implementation from
 * `openidconnect` library used by request builders and client on `oid4vci-rs`.
 */
public protocol IHttpClientProtocol: AnyObject, Sendable {
    
}
/**
 * Http client wrapper type that could either be a synchronous or asynchronous
 * external (Kotlin, Swift, etc) client implementation, receveid as a dynamic
 * trait implementation reference (`Arc<dyn (As|S)yncHttpClient`).
 *
 * `Arc` is wrapped with `IArc` to facilitate trait implementation from
 * `openidconnect` library used by request builders and client on `oid4vci-rs`.
 */
open class IHttpClient: IHttpClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_ihttpclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_ihttpclient(pointer, $0) }
    }

    
public static func newAsync(clientImpl: AsyncHttpClient) -> IHttpClient  {
    return try!  FfiConverterTypeIHttpClient_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_ihttpclient_new_async(
        FfiConverterTypeAsyncHttpClient_lower(clientImpl),$0
    )
})
}
    
public static func newSync(clientImpl: SyncHttpClient) -> IHttpClient  {
    return try!  FfiConverterTypeIHttpClient_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_ihttpclient_new_sync(
        FfiConverterTypeSyncHttpClient_lower(clientImpl),$0
    )
})
}
    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIHttpClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = IHttpClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> IHttpClient {
        return IHttpClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: IHttpClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IHttpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: IHttpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIHttpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> IHttpClient {
    return try FfiConverterTypeIHttpClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIHttpClient_lower(_ value: IHttpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIHttpClient.lower(value)
}






public protocol InProcessRecordProtocol: AnyObject, Sendable {
    
}
open class InProcessRecord: InProcessRecordProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_inprocessrecord(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_inprocessrecord(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInProcessRecord: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = InProcessRecord

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> InProcessRecord {
        return InProcessRecord(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: InProcessRecord) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InProcessRecord {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: InProcessRecord, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInProcessRecord_lift(_ pointer: UnsafeMutableRawPointer) throws -> InProcessRecord {
    return try FfiConverterTypeInProcessRecord.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInProcessRecord_lower(_ value: InProcessRecord) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInProcessRecord.lower(value)
}






public protocol InProgressRequest180137Protocol: AnyObject, Sendable {
    
    func matches()  -> [RequestMatch180137]
    
    func respond(approvedResponse: ApprovedResponse180137) async throws  -> Url?
    
}
open class InProgressRequest180137: InProgressRequest180137Protocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_inprogressrequest180137(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_inprogressrequest180137(pointer, $0) }
    }

    

    
open func matches() -> [RequestMatch180137]  {
    return try!  FfiConverterSequenceTypeRequestMatch180137.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_inprogressrequest180137_matches(self.uniffiClonePointer(),$0
    )
})
}
    
open func respond(approvedResponse: ApprovedResponse180137)async throws  -> Url?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_inprogressrequest180137_respond(
                    self.uniffiClonePointer(),
                    FfiConverterTypeApprovedResponse180137_lower(approvedResponse)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeUrl.lift,
            errorHandler: FfiConverterTypeOID4VP180137Error_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInProgressRequest180137: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = InProgressRequest180137

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> InProgressRequest180137 {
        return InProgressRequest180137(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: InProgressRequest180137) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InProgressRequest180137 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: InProgressRequest180137, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInProgressRequest180137_lift(_ pointer: UnsafeMutableRawPointer) throws -> InProgressRequest180137 {
    return try FfiConverterTypeInProgressRequest180137.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInProgressRequest180137_lower(_ value: InProgressRequest180137) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInProgressRequest180137.lower(value)
}






public protocol InProgressRequestDcApiProtocol: AnyObject, Sendable {
    
    func getMatch()  -> RequestMatch180137
    
    func getOrigin()  -> String
    
    /**
     * Generate a response for the request.
     *
     * The response is either a JWE or a serialized JSON Object.
     */
    func respond(keystore: KeyStore, approvedFields: [FieldId180137]) async throws  -> String
    
}
open class InProgressRequestDcApi: InProgressRequestDcApiProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_inprogressrequestdcapi(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_inprogressrequestdcapi(pointer, $0) }
    }

    

    
open func getMatch() -> RequestMatch180137  {
    return try!  FfiConverterTypeRequestMatch180137_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_inprogressrequestdcapi_get_match(self.uniffiClonePointer(),$0
    )
})
}
    
open func getOrigin() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_inprogressrequestdcapi_get_origin(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Generate a response for the request.
     *
     * The response is either a JWE or a serialized JSON Object.
     */
open func respond(keystore: KeyStore, approvedFields: [FieldId180137])async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_inprogressrequestdcapi_respond(
                    self.uniffiClonePointer(),
                    FfiConverterTypeKeyStore_lower(keystore),FfiConverterSequenceTypeFieldId180137.lower(approvedFields)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeDcApiError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInProgressRequestDcApi: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = InProgressRequestDcApi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> InProgressRequestDcApi {
        return InProgressRequestDcApi(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: InProgressRequestDcApi) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InProgressRequestDcApi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: InProgressRequestDcApi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInProgressRequestDcApi_lift(_ pointer: UnsafeMutableRawPointer) throws -> InProgressRequestDcApi {
    return try FfiConverterTypeInProgressRequestDcApi.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInProgressRequestDcApi_lower(_ value: InProgressRequestDcApi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInProgressRequestDcApi.lower(value)
}






public protocol IssuanceServiceClientProtocol: AnyObject, Sendable {
    
    /**
     * Checks the status of an issuance request
     *
     * # Arguments
     * * `issuance_id` - The ID of the issuance to check
     * * `wallet_attestation` - The wallet attestation JWT
     *
     * # Returns
     * * The status response containing state and openid_credential_offer if successful
     * * An error if the request fails
     */
    func checkStatus(issuanceId: String, walletAttestation: String) async throws  -> CheckStatusResponse
    
    /**
     * Creates a new issuance request
     *
     * # Arguments
     * * `wallet_attestation` - The wallet attestation JWT
     *
     * # Returns
     * * The issuance ID if successful
     * * An error if the request fails
     */
    func newIssuance(walletAttestation: String) async throws  -> String
    
}
open class IssuanceServiceClient: IssuanceServiceClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_issuanceserviceclient(self.pointer, $0) }
    }
    /**
     * Creates a new IssuanceServiceClient instance
     *
     * # Arguments
     * * `base_url` - The base URL of the issuance service
     */
public convenience init(baseUrl: String) {
    let pointer =
        try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_issuanceserviceclient_new(
        FfiConverterString.lower(baseUrl),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_issuanceserviceclient(pointer, $0) }
    }

    

    
    /**
     * Checks the status of an issuance request
     *
     * # Arguments
     * * `issuance_id` - The ID of the issuance to check
     * * `wallet_attestation` - The wallet attestation JWT
     *
     * # Returns
     * * The status response containing state and openid_credential_offer if successful
     * * An error if the request fails
     */
open func checkStatus(issuanceId: String, walletAttestation: String)async throws  -> CheckStatusResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_issuanceserviceclient_check_status(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(issuanceId),FfiConverterString.lower(walletAttestation)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeCheckStatusResponse_lift,
            errorHandler: FfiConverterTypeIssuanceServiceError_lift
        )
}
    
    /**
     * Creates a new issuance request
     *
     * # Arguments
     * * `wallet_attestation` - The wallet attestation JWT
     *
     * # Returns
     * * The issuance ID if successful
     * * An error if the request fails
     */
open func newIssuance(walletAttestation: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_issuanceserviceclient_new_issuance(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(walletAttestation)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeIssuanceServiceError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIssuanceServiceClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = IssuanceServiceClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> IssuanceServiceClient {
        return IssuanceServiceClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: IssuanceServiceClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IssuanceServiceClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: IssuanceServiceClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIssuanceServiceClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> IssuanceServiceClient {
    return try FfiConverterTypeIssuanceServiceClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIssuanceServiceClient_lower(_ value: IssuanceServiceClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIssuanceServiceClient.lower(value)
}






public protocol JsonLdPresentationBuilderProtocol: AnyObject, Sendable {
    
    func issuePresentation(credentials: [ParsedCredential]) async throws  -> String
    
}
open class JsonLdPresentationBuilder: JsonLdPresentationBuilderProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_jsonldpresentationbuilder(self.pointer, $0) }
    }
public convenience init(id: String, holder: String, proofPurpose: String, challenge: String?, domain: String?, signer: PresentationSigner, contextMap: [String: String]?) {
    let pointer =
        try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_jsonldpresentationbuilder_new(
        FfiConverterString.lower(id),
        FfiConverterString.lower(holder),
        FfiConverterString.lower(proofPurpose),
        FfiConverterOptionString.lower(challenge),
        FfiConverterOptionString.lower(domain),
        FfiConverterCallbackInterfacePresentationSigner_lower(signer),
        FfiConverterOptionDictionaryStringString.lower(contextMap),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_jsonldpresentationbuilder(pointer, $0) }
    }

    

    
open func issuePresentation(credentials: [ParsedCredential])async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_jsonldpresentationbuilder_issue_presentation(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeParsedCredential.lower(credentials)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypePresentationBuilderError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJsonLdPresentationBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = JsonLdPresentationBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> JsonLdPresentationBuilder {
        return JsonLdPresentationBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: JsonLdPresentationBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonLdPresentationBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: JsonLdPresentationBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsonLdPresentationBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> JsonLdPresentationBuilder {
    return try FfiConverterTypeJsonLdPresentationBuilder.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsonLdPresentationBuilder_lower(_ value: JsonLdPresentationBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeJsonLdPresentationBuilder.lower(value)
}






/**
 * A verifiable credential secured as JSON.
 */
public protocol JsonVcProtocol: AnyObject, Sendable {
    
    /**
     * Access the W3C VCDM credential as a JSON encoded UTF-8 string.
     */
    func credentialAsJsonEncodedUtf8String()  -> String
    
    /**
     * The local ID of this credential.
     */
    func id()  -> Uuid
    
    /**
     * The keypair identified in the credential for use in a verifiable presentation.
     */
    func keyAlias()  -> KeyAlias?
    
    /**
     * Returns the status of the credential, resolving the value in the status list,
     * along with the purpose of the status.
     */
    func status() async throws  -> Status
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
    func type()  -> CredentialType
    
    /**
     * The types of the credential from the VCDM, excluding the base `VerifiableCredential` type.
     */
    func types()  -> [String]
    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
    func vcdmVersion()  -> VcdmVersion
    
}
/**
 * A verifiable credential secured as JSON.
 */
open class JsonVc: JsonVcProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_jsonvc(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_jsonvc(pointer, $0) }
    }

    
    /**
     * Construct a new credential from UTF-8 encoded JSON.
     */
public static func newFromJson(utf8JsonString: String)throws  -> JsonVc  {
    return try  FfiConverterTypeJsonVc_lift(try rustCallWithError(FfiConverterTypeJsonVcInitError_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_jsonvc_new_from_json(
        FfiConverterString.lower(utf8JsonString),$0
    )
})
}
    
    /**
     * Construct a new credential from UTF-8 encoded JSON.
     */
public static func newFromJsonWithKey(utf8JsonString: String, keyAlias: KeyAlias)throws  -> JsonVc  {
    return try  FfiConverterTypeJsonVc_lift(try rustCallWithError(FfiConverterTypeJsonVcInitError_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_jsonvc_new_from_json_with_key(
        FfiConverterString.lower(utf8JsonString),
        FfiConverterTypeKeyAlias_lower(keyAlias),$0
    )
})
}
    

    
    /**
     * Access the W3C VCDM credential as a JSON encoded UTF-8 string.
     */
open func credentialAsJsonEncodedUtf8String() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_credential_as_json_encoded_utf8_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The local ID of this credential.
     */
open func id() -> Uuid  {
    return try!  FfiConverterTypeUuid_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The keypair identified in the credential for use in a verifiable presentation.
     */
open func keyAlias() -> KeyAlias?  {
    return try!  FfiConverterOptionTypeKeyAlias.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the status of the credential, resolving the value in the status list,
     * along with the purpose of the status.
     */
open func status()async throws  -> Status  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_jsonvc_status(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeStatus_lift,
            errorHandler: FfiConverterTypeStatusListError_lift
        )
}
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
open func type() -> CredentialType  {
    return try!  FfiConverterTypeCredentialType_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_type(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The types of the credential from the VCDM, excluding the base `VerifiableCredential` type.
     */
open func types() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_types(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
open func vcdmVersion() -> VcdmVersion  {
    return try!  FfiConverterTypeVcdmVersion_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jsonvc_vcdm_version(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJsonVc: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = JsonVc

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> JsonVc {
        return JsonVc(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: JsonVc) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonVc {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: JsonVc, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsonVc_lift(_ pointer: UnsafeMutableRawPointer) throws -> JsonVc {
    return try FfiConverterTypeJsonVc.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsonVc_lower(_ value: JsonVc) -> UnsafeMutableRawPointer {
    return FfiConverterTypeJsonVc.lower(value)
}






/**
 * A verifiable credential secured as a JWT.
 */
public protocol JwtVcProtocol: AnyObject, Sendable {
    
    /**
     * Access the W3C VCDM credential as a JSON encoded UTF-8 string.
     */
    func credentialAsJsonEncodedUtf8String()  -> String
    
    /**
     * The VdcCollection ID for this credential.
     */
    func id()  -> Uuid
    
    /**
     * Access the JWS header as a JSON encoded UTF-8 string.
     */
    func jwsHeaderAsJsonEncodedUtf8String()  -> String
    
    /**
     * Access the JWS payload as a JSON encoded UTF-8 string.
     */
    func jwsPayloadAsJsonEncodedUtf8String()  -> String
    
    /**
     * The keypair identified in the credential for use in a verifiable presentation.
     */
    func keyAlias()  -> KeyAlias?
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
    func type()  -> CredentialType
    
    /**
     * The types of the credential from the VCDM, excluding the base `VerifiableCredential` type.
     */
    func types()  -> [String]
    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
    func vcdmVersion()  -> VcdmVersion
    
}
/**
 * A verifiable credential secured as a JWT.
 */
open class JwtVc: JwtVcProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_jwtvc(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_jwtvc(pointer, $0) }
    }

    
    /**
     * Construct a new credential from a compact JWS (of the form
     * `<base64-encoded-header>.<base64-encoded-payload>.<base64-encoded-signature>`),
     * without an associated keypair.
     */
public static func newFromCompactJws(jws: String)throws  -> JwtVc  {
    return try  FfiConverterTypeJwtVc_lift(try rustCallWithError(FfiConverterTypeJwtVcInitError_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_jwtvc_new_from_compact_jws(
        FfiConverterString.lower(jws),$0
    )
})
}
    
    /**
     * Construct a new credential from a compact JWS (of the form
     * `<base64-encoded-header>.<base64-encoded-payload>.<base64-encoded-signature>`),
     * with an associated keypair.
     */
public static func newFromCompactJwsWithKey(jws: String, keyAlias: KeyAlias)throws  -> JwtVc  {
    return try  FfiConverterTypeJwtVc_lift(try rustCallWithError(FfiConverterTypeJwtVcInitError_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_jwtvc_new_from_compact_jws_with_key(
        FfiConverterString.lower(jws),
        FfiConverterTypeKeyAlias_lower(keyAlias),$0
    )
})
}
    

    
    /**
     * Access the W3C VCDM credential as a JSON encoded UTF-8 string.
     */
open func credentialAsJsonEncodedUtf8String() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_credential_as_json_encoded_utf8_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The VdcCollection ID for this credential.
     */
open func id() -> Uuid  {
    return try!  FfiConverterTypeUuid_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Access the JWS header as a JSON encoded UTF-8 string.
     */
open func jwsHeaderAsJsonEncodedUtf8String() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_jws_header_as_json_encoded_utf8_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Access the JWS payload as a JSON encoded UTF-8 string.
     */
open func jwsPayloadAsJsonEncodedUtf8String() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_jws_payload_as_json_encoded_utf8_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The keypair identified in the credential for use in a verifiable presentation.
     */
open func keyAlias() -> KeyAlias?  {
    return try!  FfiConverterOptionTypeKeyAlias.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
open func type() -> CredentialType  {
    return try!  FfiConverterTypeCredentialType_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_type(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The types of the credential from the VCDM, excluding the base `VerifiableCredential` type.
     */
open func types() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_types(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The version of the Verifiable Credential Data Model that this credential conforms to.
     */
open func vcdmVersion() -> VcdmVersion  {
    return try!  FfiConverterTypeVcdmVersion_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_jwtvc_vcdm_version(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJwtVc: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = JwtVc

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> JwtVc {
        return JwtVc(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: JwtVc) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JwtVc {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: JwtVc, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJwtVc_lift(_ pointer: UnsafeMutableRawPointer) throws -> JwtVc {
    return try FfiConverterTypeJwtVc.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJwtVc_lower(_ value: JwtVc) -> UnsafeMutableRawPointer {
    return FfiConverterTypeJwtVc.lower(value)
}






/**
 * An interface that can provide access to cryptographic keypairs from the native crypto API.
 */
public protocol KeyStore: AnyObject, Sendable {
    
    /**
     * Retrieve a cryptographic keypair by alias. The cryptographic key must be usable for
     * creating digital signatures, and must not be usable for encryption.
     */
    func getSigningKey(alias: KeyAlias) throws  -> SigningKey
    
}
/**
 * An interface that can provide access to cryptographic keypairs from the native crypto API.
 */
open class KeyStoreImpl: KeyStore, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_keystore(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_keystore(pointer, $0) }
    }

    

    
    /**
     * Retrieve a cryptographic keypair by alias. The cryptographic key must be usable for
     * creating digital signatures, and must not be usable for encryption.
     */
open func getSigningKey(alias: KeyAlias)throws  -> SigningKey  {
    return try  FfiConverterTypeSigningKey_lift(try rustCallWithError(FfiConverterTypeCryptoError_lift) {
    uniffi_mobile_sdk_rs_fn_method_keystore_get_signing_key(self.uniffiClonePointer(),
        FfiConverterTypeKeyAlias_lower(alias),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceKeyStore {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceKeyStore] = [UniffiVTableCallbackInterfaceKeyStore(
        getSigningKey: { (
            uniffiHandle: UInt64,
            alias: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<UnsafeMutableRawPointer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> SigningKey in
                guard let uniffiObj = try? FfiConverterTypeKeyStore.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.getSigningKey(
                     alias: try FfiConverterTypeKeyAlias_lift(alias)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeSigningKey_lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeCryptoError_lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeKeyStore.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface KeyStore: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitKeyStore() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_keystore(UniffiCallbackInterfaceKeyStore.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyStore: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<KeyStore>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = KeyStore

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> KeyStore {
        return KeyStoreImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: KeyStore) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyStore {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: KeyStore, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyStore_lift(_ pointer: UnsafeMutableRawPointer) throws -> KeyStore {
    return try FfiConverterTypeKeyStore.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyStore_lower(_ value: KeyStore) -> UnsafeMutableRawPointer {
    return FfiConverterTypeKeyStore.lower(value)
}






public protocol LogWriter: AnyObject, Sendable {
    
    func writeToBuffer(message: Data) 
    
    func flush() 
    
}
open class LogWriterImpl: LogWriter, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_logwriter(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_logwriter(pointer, $0) }
    }

    

    
open func writeToBuffer(message: Data)  {try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_logwriter_write_to_buffer(self.uniffiClonePointer(),
        FfiConverterData.lower(message),$0
    )
}
}
    
open func flush()  {try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_logwriter_flush(self.uniffiClonePointer(),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLogWriter {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceLogWriter] = [UniffiVTableCallbackInterfaceLogWriter(
        writeToBuffer: { (
            uniffiHandle: UInt64,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeLogWriter.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.writeToBuffer(
                     message: try FfiConverterData.lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        flush: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeLogWriter.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.flush(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeLogWriter.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface LogWriter: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitLogWriter() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_logwriter(UniffiCallbackInterfaceLogWriter.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogWriter: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<LogWriter>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LogWriter

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LogWriter {
        return LogWriterImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LogWriter) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogWriter {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LogWriter, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogWriter_lift(_ pointer: UnsafeMutableRawPointer) throws -> LogWriter {
    return try FfiConverterTypeLogWriter.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogWriter_lower(_ value: LogWriter) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLogWriter.lower(value)
}






public protocol MdlSessionManagerProtocol: AnyObject, Sendable {
    
}
open class MdlSessionManager: MdlSessionManagerProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_mdlsessionmanager(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_mdlsessionmanager(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMDLSessionManager: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MdlSessionManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MdlSessionManager {
        return MdlSessionManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MdlSessionManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlSessionManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MdlSessionManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDLSessionManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> MdlSessionManager {
    return try FfiConverterTypeMDLSessionManager.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDLSessionManager_lower(_ value: MdlSessionManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMDLSessionManager.lower(value)
}






public protocol MdlPresentationSessionProtocol: AnyObject, Sendable {
    
    /**
     * Constructs the response to be sent from the holder to the reader containing
     * the items of information the user has consented to share.
     *
     * Takes a HashMap of items the user has authorized the app to share, as well
     * as the id of a key stored in the key manager to be used to sign the response.
     * Returns a byte array containing the signed response to be returned to the
     * reader.
     */
    func generateResponse(permittedItems: [String: [String: [String]]]) throws  -> Data
    
    /**
     * Returns the BLE identification
     */
    func getBleIdent()  -> Data
    
    /**
     * Returns the generated QR code
     */
    func getQrCodeUri()  -> String
    
    /**
     * Handle a request from a reader that is seeking information from the mDL holder.
     *
     * Takes the raw bytes received from the reader by the holder over the transmission
     * technology. Returns a Vector of information items requested by the reader, or an
     * error.
     */
    func handleRequest(request: Data) throws  -> [ItemsRequest]
    
    func submitResponse(signature: Data) throws  -> Data
    
    /**
     * Terminates the mDL exchange session.
     *
     * Returns the termination message to be transmitted to the reader.
     */
    func terminateSession() throws  -> Data
    
}
open class MdlPresentationSession: MdlPresentationSessionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_mdlpresentationsession(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_mdlpresentationsession(pointer, $0) }
    }

    

    
    /**
     * Constructs the response to be sent from the holder to the reader containing
     * the items of information the user has consented to share.
     *
     * Takes a HashMap of items the user has authorized the app to share, as well
     * as the id of a key stored in the key manager to be used to sign the response.
     * Returns a byte array containing the signed response to be returned to the
     * reader.
     */
open func generateResponse(permittedItems: [String: [String: [String]]])throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSignatureError_lift) {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_generate_response(self.uniffiClonePointer(),
        FfiConverterDictionaryStringDictionaryStringSequenceString.lower(permittedItems),$0
    )
})
}
    
    /**
     * Returns the BLE identification
     */
open func getBleIdent() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_get_ble_ident(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the generated QR code
     */
open func getQrCodeUri() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_get_qr_code_uri(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Handle a request from a reader that is seeking information from the mDL holder.
     *
     * Takes the raw bytes received from the reader by the holder over the transmission
     * technology. Returns a Vector of information items requested by the reader, or an
     * error.
     */
open func handleRequest(request: Data)throws  -> [ItemsRequest]  {
    return try  FfiConverterSequenceTypeItemsRequest.lift(try rustCallWithError(FfiConverterTypeRequestError_lift) {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_handle_request(self.uniffiClonePointer(),
        FfiConverterData.lower(request),$0
    )
})
}
    
open func submitResponse(signature: Data)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeSignatureError_lift) {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_submit_response(self.uniffiClonePointer(),
        FfiConverterData.lower(signature),$0
    )
})
}
    
    /**
     * Terminates the mDL exchange session.
     *
     * Returns the termination message to be transmitted to the reader.
     */
open func terminateSession()throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeTerminationError_lift) {
    uniffi_mobile_sdk_rs_fn_method_mdlpresentationsession_terminate_session(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMdlPresentationSession: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = MdlPresentationSession

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> MdlPresentationSession {
        return MdlPresentationSession(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: MdlPresentationSession) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlPresentationSession {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: MdlPresentationSession, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdlPresentationSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> MdlPresentationSession {
    return try FfiConverterTypeMdlPresentationSession.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdlPresentationSession_lower(_ value: MdlPresentationSession) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMdlPresentationSession.lower(value)
}






public protocol MdocProtocol: AnyObject, Sendable {
    
    /**
     * Simple representation of mdoc namespace and data elements for display in the UI.
     */
    func details()  -> [Namespace: [Element]]
    
    /**
     * The document type of this mdoc, for example `org.iso.18013.5.1.mDL`.
     */
    func doctype()  -> String
    
    /**
     * The local ID of this credential.
     */
    func id()  -> Uuid
    
    func keyAlias()  -> KeyAlias
    
}
open class Mdoc: MdocProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_mdoc(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_mdoc(pointer, $0) }
    }

    
    /**
     * Construct a SpruceKit MDoc from a cbor-encoded
     * [spruceid/isomdl `Document`](https://github.com/spruceid/isomdl/blob/main/src/presentation/device.rs#L145-L152)
     */
public static func fromCborEncodedDocument(cborEncodedDocument: Data, keyAlias: KeyAlias)throws  -> Mdoc  {
    return try  FfiConverterTypeMdoc_lift(try rustCallWithError(FfiConverterTypeMdocInitError_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_mdoc_from_cbor_encoded_document(
        FfiConverterData.lower(cborEncodedDocument),
        FfiConverterTypeKeyAlias_lower(keyAlias),$0
    )
})
}
    
    /**
     * Compatibility feature: construct an MDoc from a
     * [stringified spruceid/isomdl `Document`](https://github.com/spruceid/isomdl/blob/main/src/presentation/mod.rs#L100)
     */
public static func fromStringifiedDocument(stringifiedDocument: String, keyAlias: KeyAlias)throws  -> Mdoc  {
    return try  FfiConverterTypeMdoc_lift(try rustCallWithError(FfiConverterTypeMdocInitError_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_mdoc_from_stringified_document(
        FfiConverterString.lower(stringifiedDocument),
        FfiConverterTypeKeyAlias_lower(keyAlias),$0
    )
})
}
    
    /**
     * Construct a new MDoc from base64url-encoded IssuerSigned.
     */
public static func newFromBase64urlEncodedIssuerSigned(base64urlEncodedIssuerSigned: String, keyAlias: KeyAlias)throws  -> Mdoc  {
    return try  FfiConverterTypeMdoc_lift(try rustCallWithError(FfiConverterTypeMdocInitError_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_mdoc_new_from_base64url_encoded_issuer_signed(
        FfiConverterString.lower(base64urlEncodedIssuerSigned),
        FfiConverterTypeKeyAlias_lower(keyAlias),$0
    )
})
}
    

    
    /**
     * Simple representation of mdoc namespace and data elements for display in the UI.
     */
open func details() -> [Namespace: [Element]]  {
    return try!  FfiConverterDictionaryTypeNamespaceSequenceTypeElement.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdoc_details(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The document type of this mdoc, for example `org.iso.18013.5.1.mDL`.
     */
open func doctype() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdoc_doctype(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * The local ID of this credential.
     */
open func id() -> Uuid  {
    return try!  FfiConverterTypeUuid_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdoc_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func keyAlias() -> KeyAlias  {
    return try!  FfiConverterTypeKeyAlias_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_mdoc_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMdoc: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Mdoc

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Mdoc {
        return Mdoc(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Mdoc) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mdoc {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Mdoc, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdoc_lift(_ pointer: UnsafeMutableRawPointer) throws -> Mdoc {
    return try FfiConverterTypeMdoc.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdoc_lower(_ value: Mdoc) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMdoc.lower(value)
}






/**
 * Handler for OpenID4VP requests according to the profile in ISO/IEC 18013-7 Annex B.
 *
 * Notably this supports requests which use the URI scheme `mdoc-openid4vp://`.
 */
public protocol Oid4vp180137Protocol: AnyObject, Sendable {
    
    func processRequest(url: Url) async throws  -> InProgressRequest180137
    
}
/**
 * Handler for OpenID4VP requests according to the profile in ISO/IEC 18013-7 Annex B.
 *
 * Notably this supports requests which use the URI scheme `mdoc-openid4vp://`.
 */
open class Oid4vp180137: Oid4vp180137Protocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_oid4vp180137(self.pointer, $0) }
    }
public convenience init(credentials: [Mdoc], keystore: KeyStore)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeOID4VP180137Error_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vp180137_new(
        FfiConverterSequenceTypeMdoc.lower(credentials),
        FfiConverterTypeKeyStore_lower(keystore),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_oid4vp180137(pointer, $0) }
    }

    

    
open func processRequest(url: Url)async throws  -> InProgressRequest180137  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_oid4vp180137_process_request(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUrl_lower(url)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeInProgressRequest180137_lift,
            errorHandler: FfiConverterTypeOID4VP180137Error_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOID4VP180137: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Oid4vp180137

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vp180137 {
        return Oid4vp180137(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Oid4vp180137) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vp180137 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Oid4vp180137, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOID4VP180137_lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vp180137 {
    return try FfiConverterTypeOID4VP180137.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOID4VP180137_lower(_ value: Oid4vp180137) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOID4VP180137.lower(value)
}






public protocol Oid4vciProtocol: AnyObject, Sendable {
    
    func clearContextMap() throws 
    
    func exchangeCredential(proofsOfPossession: [String], options: Oid4vciExchangeOptions) async throws  -> [CredentialResponse]
    
    func exchangeToken() async throws  -> String?
    
    func getMetadata() throws  -> Oid4vciMetadata
    
    func initiate(baseUrl: String, clientId: String, redirectUrl: String) async throws 
    
    func initiateWithOffer(credentialOffer: String, clientId: String, redirectUrl: String) async throws 
    
    func setContextMap(values: [String: String]) throws 
    
}
open class Oid4vci: Oid4vciProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_oid4vci(self.pointer, $0) }
    }
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_oid4vci(pointer, $0) }
    }

    
public static func newWithAsyncClient(client: AsyncHttpClient) -> Oid4vci  {
    return try!  FfiConverterTypeOid4vci_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new_with_async_client(
        FfiConverterTypeAsyncHttpClient_lower(client),$0
    )
})
}
    
public static func newWithDefaultAsyncClient() -> Oid4vci  {
    return try!  FfiConverterTypeOid4vci_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new_with_default_async_client($0
    )
})
}
    
public static func newWithDefaultSyncClient() -> Oid4vci  {
    return try!  FfiConverterTypeOid4vci_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new_with_default_sync_client($0
    )
})
}
    
public static func newWithSyncClient(client: SyncHttpClient) -> Oid4vci  {
    return try!  FfiConverterTypeOid4vci_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_oid4vci_new_with_sync_client(
        FfiConverterTypeSyncHttpClient_lower(client),$0
    )
})
}
    

    
open func clearContextMap()throws   {try rustCallWithError(FfiConverterTypeOid4vciError_lift) {
    uniffi_mobile_sdk_rs_fn_method_oid4vci_clear_context_map(self.uniffiClonePointer(),$0
    )
}
}
    
open func exchangeCredential(proofsOfPossession: [String], options: Oid4vciExchangeOptions)async throws  -> [CredentialResponse]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_oid4vci_exchange_credential(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceString.lower(proofsOfPossession),FfiConverterTypeOid4vciExchangeOptions_lower(options)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeCredentialResponse.lift,
            errorHandler: FfiConverterTypeOid4vciError_lift
        )
}
    
open func exchangeToken()async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_oid4vci_exchange_token(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeOid4vciError_lift
        )
}
    
open func getMetadata()throws  -> Oid4vciMetadata  {
    return try  FfiConverterTypeOid4vciMetadata_lift(try rustCallWithError(FfiConverterTypeOid4vciError_lift) {
    uniffi_mobile_sdk_rs_fn_method_oid4vci_get_metadata(self.uniffiClonePointer(),$0
    )
})
}
    
open func initiate(baseUrl: String, clientId: String, redirectUrl: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_oid4vci_initiate(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(baseUrl),FfiConverterString.lower(clientId),FfiConverterString.lower(redirectUrl)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeOid4vciError_lift
        )
}
    
open func initiateWithOffer(credentialOffer: String, clientId: String, redirectUrl: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_oid4vci_initiate_with_offer(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(credentialOffer),FfiConverterString.lower(clientId),FfiConverterString.lower(redirectUrl)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeOid4vciError_lift
        )
}
    
open func setContextMap(values: [String: String])throws   {try rustCallWithError(FfiConverterTypeOid4vciError_lift) {
    uniffi_mobile_sdk_rs_fn_method_oid4vci_set_context_map(self.uniffiClonePointer(),
        FfiConverterDictionaryStringString.lower(values),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOid4vci: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Oid4vci

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vci {
        return Oid4vci(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Oid4vci) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vci {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Oid4vci, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOid4vci_lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vci {
    return try FfiConverterTypeOid4vci.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOid4vci_lower(_ value: Oid4vci) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOid4vci.lower(value)
}






public protocol Oid4vciMetadataProtocol: AnyObject, Sendable {
    
    func authorizationServers()  -> [String]?
    
    func batchCredentialEndpoint()  -> String?
    
    func credentialEndpoint()  -> String
    
    func deferredCredentialEndpoint()  -> String?
    
    func issuer()  -> String
    
    func notificationEndpoint()  -> String?
    
    func toJson() throws  -> String
    
}
open class Oid4vciMetadata: Oid4vciMetadataProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_oid4vcimetadata(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_oid4vcimetadata(pointer, $0) }
    }

    

    
open func authorizationServers() -> [String]?  {
    return try!  FfiConverterOptionSequenceString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_authorization_servers(self.uniffiClonePointer(),$0
    )
})
}
    
open func batchCredentialEndpoint() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_batch_credential_endpoint(self.uniffiClonePointer(),$0
    )
})
}
    
open func credentialEndpoint() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_credential_endpoint(self.uniffiClonePointer(),$0
    )
})
}
    
open func deferredCredentialEndpoint() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_deferred_credential_endpoint(self.uniffiClonePointer(),$0
    )
})
}
    
open func issuer() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_issuer(self.uniffiClonePointer(),$0
    )
})
}
    
open func notificationEndpoint() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_notification_endpoint(self.uniffiClonePointer(),$0
    )
})
}
    
open func toJson()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeOid4vciError_lift) {
    uniffi_mobile_sdk_rs_fn_method_oid4vcimetadata_to_json(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOid4vciMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Oid4vciMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vciMetadata {
        return Oid4vciMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Oid4vciMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vciMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Oid4vciMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOid4vciMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vciMetadata {
    return try FfiConverterTypeOid4vciMetadata.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOid4vciMetadata_lower(_ value: Oid4vciMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOid4vciMetadata.lower(value)
}






public protocol Oid4vciSessionProtocol: AnyObject, Sendable {
    
}
open class Oid4vciSession: Oid4vciSessionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_oid4vcisession(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_oid4vcisession(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOid4vciSession: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Oid4vciSession

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vciSession {
        return Oid4vciSession(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Oid4vciSession) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vciSession {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Oid4vciSession, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOid4vciSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> Oid4vciSession {
    return try FfiConverterTypeOid4vciSession.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOid4vciSession_lower(_ value: Oid4vciSession) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOid4vciSession.lower(value)
}






/**
 * A credential that has been parsed as a known variant.
 */
public protocol ParsedCredentialProtocol: AnyObject, Sendable {
    
    /**
     * Return the credential as an CWT, if it is of that format.
     */
    func asCwt()  -> Cwt?
    
    /**
     * Return the credential as a JsonVc if it is of that format.
     */
    func asJsonVc()  -> JsonVc?
    
    /**
     * Return the credential as a JwtVc if it is of that format.
     */
    func asJwtVc()  -> JwtVc?
    
    /**
     * Return the credential as an Mdoc if it is of that format.
     */
    func asMsoMdoc()  -> Mdoc?
    
    /**
     * Return the credential as an SD-JWT, if it is of that format.
     */
    func asSdJwt()  -> Vcdm2SdJwt?
    
    /**
     * Return the format of the credential.
     */
    func format()  -> CredentialFormat
    
    /**
     * Get the local ID for this credential.
     */
    func id()  -> Uuid
    
    /**
     * Convert a parsed credential into the generic form for storage.
     */
    func intoGenericForm() throws  -> Credential
    
    /**
     * Get the key alias for this credential.
     */
    func keyAlias()  -> KeyAlias?
    
    /**
     * Return the CredentialType from the parsed credential.
     */
    func type()  -> CredentialType
    
}
/**
 * A credential that has been parsed as a known variant.
 */
open class ParsedCredential: ParsedCredentialProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_parsedcredential(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_parsedcredential(pointer, $0) }
    }

    
    /**
     * Construct a new `cwt` credential.
     */
public static func newCwt(cwt: Cwt) -> ParsedCredential  {
    return try!  FfiConverterTypeParsedCredential_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_cwt(
        FfiConverterTypeCwt_lower(cwt),$0
    )
})
}
    
public static func newFromJson(jsonString: String)throws  -> ParsedCredential  {
    return try  FfiConverterTypeParsedCredential_lift(try rustCallWithError(FfiConverterTypeCredentialDecodingError_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_from_json(
        FfiConverterString.lower(jsonString),$0
    )
})
}
    
    /**
     * This method attempts to parse the credential depending on the credential format type provided.
     */
public static func newFromStringWithFormat(format: String, credential: String, keyAlias: KeyAlias)throws  -> ParsedCredential  {
    return try  FfiConverterTypeParsedCredential_lift(try rustCallWithError(FfiConverterTypeCredentialDecodingError_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_from_string_with_format(
        FfiConverterString.lower(format),
        FfiConverterString.lower(credential),
        FfiConverterTypeKeyAlias_lower(keyAlias),$0
    )
})
}
    
    /**
     * Construct a new `jwt_vc_json` credential.
     */
public static func newJwtVcJson(jwtVc: JwtVc) -> ParsedCredential  {
    return try!  FfiConverterTypeParsedCredential_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_jwt_vc_json(
        FfiConverterTypeJwtVc_lower(jwtVc),$0
    )
})
}
    
    /**
     * Construct a new `jwt_vc_json-ld` credential.
     */
public static func newJwtVcJsonLd(jwtVc: JwtVc) -> ParsedCredential  {
    return try!  FfiConverterTypeParsedCredential_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_jwt_vc_json_ld(
        FfiConverterTypeJwtVc_lower(jwtVc),$0
    )
})
}
    
    /**
     * Construct a new `ldp_vc` credential.
     */
public static func newLdpVc(jsonVc: JsonVc) -> ParsedCredential  {
    return try!  FfiConverterTypeParsedCredential_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_ldp_vc(
        FfiConverterTypeJsonVc_lower(jsonVc),$0
    )
})
}
    
    /**
     * Construct a new `mso_mdoc` credential.
     */
public static func newMsoMdoc(mdoc: Mdoc) -> ParsedCredential  {
    return try!  FfiConverterTypeParsedCredential_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_mso_mdoc(
        FfiConverterTypeMdoc_lower(mdoc),$0
    )
})
}
    
    /**
     * Construct a new `sd_jwt_vc` credential.
     */
public static func newSdJwt(sdJwtVc: Vcdm2SdJwt) -> ParsedCredential  {
    return try!  FfiConverterTypeParsedCredential_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_new_sd_jwt(
        FfiConverterTypeVCDM2SdJwt_lower(sdJwtVc),$0
    )
})
}
    
    /**
     * Parse a credential from the generic form retrieved from storage.
     */
public static func parseFromCredential(credential: Credential)throws  -> ParsedCredential  {
    return try  FfiConverterTypeParsedCredential_lift(try rustCallWithError(FfiConverterTypeCredentialDecodingError_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_parsedcredential_parse_from_credential(
        FfiConverterTypeCredential_lower(credential),$0
    )
})
}
    

    
    /**
     * Return the credential as an CWT, if it is of that format.
     */
open func asCwt() -> Cwt?  {
    return try!  FfiConverterOptionTypeCwt.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_as_cwt(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the credential as a JsonVc if it is of that format.
     */
open func asJsonVc() -> JsonVc?  {
    return try!  FfiConverterOptionTypeJsonVc.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_as_json_vc(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the credential as a JwtVc if it is of that format.
     */
open func asJwtVc() -> JwtVc?  {
    return try!  FfiConverterOptionTypeJwtVc.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_as_jwt_vc(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the credential as an Mdoc if it is of that format.
     */
open func asMsoMdoc() -> Mdoc?  {
    return try!  FfiConverterOptionTypeMdoc.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_as_mso_mdoc(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the credential as an SD-JWT, if it is of that format.
     */
open func asSdJwt() -> Vcdm2SdJwt?  {
    return try!  FfiConverterOptionTypeVCDM2SdJwt.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_as_sd_jwt(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the format of the credential.
     */
open func format() -> CredentialFormat  {
    return try!  FfiConverterTypeCredentialFormat_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_format(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the local ID for this credential.
     */
open func id() -> Uuid  {
    return try!  FfiConverterTypeUuid_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Convert a parsed credential into the generic form for storage.
     */
open func intoGenericForm()throws  -> Credential  {
    return try  FfiConverterTypeCredential_lift(try rustCallWithError(FfiConverterTypeCredentialEncodingError_lift) {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_into_generic_form(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the key alias for this credential.
     */
open func keyAlias() -> KeyAlias?  {
    return try!  FfiConverterOptionTypeKeyAlias.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the CredentialType from the parsed credential.
     */
open func type() -> CredentialType  {
    return try!  FfiConverterTypeCredentialType_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_parsedcredential_type(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParsedCredential: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ParsedCredential

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ParsedCredential {
        return ParsedCredential(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ParsedCredential) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParsedCredential {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ParsedCredential, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedCredential_lift(_ pointer: UnsafeMutableRawPointer) throws -> ParsedCredential {
    return try FfiConverterTypeParsedCredential.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParsedCredential_lower(_ value: ParsedCredential) -> UnsafeMutableRawPointer {
    return FfiConverterTypeParsedCredential.lower(value)
}






public protocol PermissionRequestProtocol: AnyObject, Sendable {
    
    /**
     * Return the client ID for the authorization request.
     *
     * This can be used by the user interface to show who
     * is requesting the presentation from the wallet holder.
     */
    func clientId()  -> String?
    
    /**
     * Construct a new permission response for the given credential.
     *
     * NOTE: `should_strip_quotes` is a non-normative setting to determine
     * the behavior of removing extra quotations around a JSON
     * string encoded vp_token, e.g. "'[{ @context: [...] }]'" -> '[{ @context: [...] }]'
     */
    func createPermissionResponse(selectedCredentials: [PresentableCredential], selectedFields: [[String]], responseOptions: ResponseOptions) async throws  -> PermissionResponse
    
    /**
     * Return the filtered list of credentials that matched
     * the presentation definition.
     */
    func credentials()  -> [PresentableCredential]
    
    /**
     * Return the domain name of the redirect URI.
     *
     * This can be used by the user interface to show where
     * the presentation will be sent. It may also be used to show
     * the domain name of the verifier as an alternative to the client_id.
     */
    func domain()  -> String?
    
    /**
     * Return the purpose of the presentation request.
     */
    func purpose()  -> String?
    
    /**
     * Return the requested fields for a given credential.
     *
     * NOTE: This will return only the requested fields for a given credential.
     */
    func requestedFields(credential: PresentableCredential)  -> [RequestedField]
    
}
open class PermissionRequest: PermissionRequestProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_permissionrequest(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_permissionrequest(pointer, $0) }
    }

    

    
    /**
     * Return the client ID for the authorization request.
     *
     * This can be used by the user interface to show who
     * is requesting the presentation from the wallet holder.
     */
open func clientId() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_permissionrequest_client_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Construct a new permission response for the given credential.
     *
     * NOTE: `should_strip_quotes` is a non-normative setting to determine
     * the behavior of removing extra quotations around a JSON
     * string encoded vp_token, e.g. "'[{ @context: [...] }]'" -> '[{ @context: [...] }]'
     */
open func createPermissionResponse(selectedCredentials: [PresentableCredential], selectedFields: [[String]], responseOptions: ResponseOptions)async throws  -> PermissionResponse  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_permissionrequest_create_permission_response(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypePresentableCredential.lower(selectedCredentials),FfiConverterSequenceSequenceString.lower(selectedFields),FfiConverterTypeResponseOptions_lower(responseOptions)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypePermissionResponse_lift,
            errorHandler: FfiConverterTypeOID4VPError_lift
        )
}
    
    /**
     * Return the filtered list of credentials that matched
     * the presentation definition.
     */
open func credentials() -> [PresentableCredential]  {
    return try!  FfiConverterSequenceTypePresentableCredential.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_permissionrequest_credentials(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the domain name of the redirect URI.
     *
     * This can be used by the user interface to show where
     * the presentation will be sent. It may also be used to show
     * the domain name of the verifier as an alternative to the client_id.
     */
open func domain() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_permissionrequest_domain(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the purpose of the presentation request.
     */
open func purpose() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_permissionrequest_purpose(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the requested fields for a given credential.
     *
     * NOTE: This will return only the requested fields for a given credential.
     */
open func requestedFields(credential: PresentableCredential) -> [RequestedField]  {
    return try!  FfiConverterSequenceTypeRequestedField.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_permissionrequest_requested_fields(self.uniffiClonePointer(),
        FfiConverterTypePresentableCredential_lower(credential),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePermissionRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PermissionRequest

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PermissionRequest {
        return PermissionRequest(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PermissionRequest) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PermissionRequest {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PermissionRequest, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePermissionRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> PermissionRequest {
    return try FfiConverterTypePermissionRequest.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePermissionRequest_lower(_ value: PermissionRequest) -> UnsafeMutableRawPointer {
    return FfiConverterTypePermissionRequest.lower(value)
}






/**
 * This struct is used to represent the response to a permission request.
 *
 * Use the [PermissionResponse::new] method to create a new instance of the PermissionResponse.
 *
 * The Requested Fields are created by calling the [PermissionRequest::requested_fields] method, and then
 * explicitly setting the permission to true or false, based on the holder's decision.
 */
public protocol PermissionResponseProtocol: AnyObject, Sendable {
    
    /**
     * Return the selected credentials for the permission response.
     */
    func selectedCredentials()  -> [PresentableCredential]
    
    /**
     * Return the signed (prepared) vp token as a JSON-encoded utf-8 string.
     *
     * This is helpful for debugging purposes, and is not intended to be used
     * for submitting the response to the verifier.
     */
    func vpToken() throws  -> String
    
}
/**
 * This struct is used to represent the response to a permission request.
 *
 * Use the [PermissionResponse::new] method to create a new instance of the PermissionResponse.
 *
 * The Requested Fields are created by calling the [PermissionRequest::requested_fields] method, and then
 * explicitly setting the permission to true or false, based on the holder's decision.
 */
open class PermissionResponse: PermissionResponseProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_permissionresponse(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_permissionresponse(pointer, $0) }
    }

    

    
    /**
     * Return the selected credentials for the permission response.
     */
open func selectedCredentials() -> [PresentableCredential]  {
    return try!  FfiConverterSequenceTypePresentableCredential.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_permissionresponse_selected_credentials(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the signed (prepared) vp token as a JSON-encoded utf-8 string.
     *
     * This is helpful for debugging purposes, and is not intended to be used
     * for submitting the response to the verifier.
     */
open func vpToken()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeOID4VPError_lift) {
    uniffi_mobile_sdk_rs_fn_method_permissionresponse_vp_token(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePermissionResponse: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PermissionResponse

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PermissionResponse {
        return PermissionResponse(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PermissionResponse) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PermissionResponse {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PermissionResponse, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePermissionResponse_lift(_ pointer: UnsafeMutableRawPointer) throws -> PermissionResponse {
    return try FfiConverterTypePermissionResponse.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePermissionResponse_lower(_ value: PermissionResponse) -> UnsafeMutableRawPointer {
    return FfiConverterTypePermissionResponse.lower(value)
}






/**
 * A credential that has been parsed as a known variant.
 */
public protocol PresentableCredentialProtocol: AnyObject, Sendable {
    
    /**
     * Converts to the primitive ParsedCredential type
     */
    func asParsedCredential()  -> ParsedCredential
    
    /**
     * Return if the credential supports selective disclosure
     * For now only SdJwts are supported
     */
    func selectiveDisclosable()  -> Bool
    
}
/**
 * A credential that has been parsed as a known variant.
 */
open class PresentableCredential: PresentableCredentialProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_presentablecredential(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_presentablecredential(pointer, $0) }
    }

    

    
    /**
     * Converts to the primitive ParsedCredential type
     */
open func asParsedCredential() -> ParsedCredential  {
    return try!  FfiConverterTypeParsedCredential_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_presentablecredential_as_parsed_credential(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return if the credential supports selective disclosure
     * For now only SdJwts are supported
     */
open func selectiveDisclosable() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_presentablecredential_selective_disclosable(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePresentableCredential: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PresentableCredential

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PresentableCredential {
        return PresentableCredential(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PresentableCredential) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PresentableCredential {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PresentableCredential, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePresentableCredential_lift(_ pointer: UnsafeMutableRawPointer) throws -> PresentableCredential {
    return try FfiConverterTypePresentableCredential.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePresentableCredential_lower(_ value: PresentableCredential) -> UnsafeMutableRawPointer {
    return FfiConverterTypePresentableCredential.lower(value)
}






/**
 * A viable match for the credential request.
 */
public protocol RequestMatch180137Protocol: AnyObject, Sendable {
    
    func credentialId()  -> Uuid
    
    func requestedFields()  -> [RequestedField180137]
    
}
/**
 * A viable match for the credential request.
 */
open class RequestMatch180137: RequestMatch180137Protocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_requestmatch180137(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_requestmatch180137(pointer, $0) }
    }

    

    
open func credentialId() -> Uuid  {
    return try!  FfiConverterTypeUuid_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestmatch180137_credential_id(self.uniffiClonePointer(),$0
    )
})
}
    
open func requestedFields() -> [RequestedField180137]  {
    return try!  FfiConverterSequenceTypeRequestedField180137.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestmatch180137_requested_fields(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestMatch180137: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RequestMatch180137

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RequestMatch180137 {
        return RequestMatch180137(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RequestMatch180137) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestMatch180137 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RequestMatch180137, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestMatch180137_lift(_ pointer: UnsafeMutableRawPointer) throws -> RequestMatch180137 {
    return try FfiConverterTypeRequestMatch180137.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestMatch180137_lower(_ value: RequestMatch180137) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRequestMatch180137.lower(value)
}






public protocol RequestedFieldProtocol: AnyObject, Sendable {
    
    /**
     * Return the unique ID for the request field.
     */
    func id()  -> Uuid
    
    /**
     * Return the input descriptor id the requested field belongs to
     */
    func inputDescriptorId()  -> String
    
    /**
     * Return the field name
     */
    func name()  -> String?
    
    /**
     * Return the JsonPath of the field
     */
    func path()  -> String
    
    /**
     * Return the purpose of the requested field.
     */
    func purpose()  -> String?
    
    /**
     * Return the stringified JSON raw fields.
     */
    func rawFields()  -> [String]
    
    /**
     * Return the field required status
     */
    func required()  -> Bool
    
    /**
     * Return the field retained status
     */
    func retained()  -> Bool
    
}
open class RequestedField: RequestedFieldProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_requestedfield(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_requestedfield(pointer, $0) }
    }

    

    
    /**
     * Return the unique ID for the request field.
     */
open func id() -> Uuid  {
    return try!  FfiConverterTypeUuid_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestedfield_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the input descriptor id the requested field belongs to
     */
open func inputDescriptorId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestedfield_input_descriptor_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the field name
     */
open func name() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestedfield_name(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the JsonPath of the field
     */
open func path() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestedfield_path(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the purpose of the requested field.
     */
open func purpose() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestedfield_purpose(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the stringified JSON raw fields.
     */
open func rawFields() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestedfield_raw_fields(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the field required status
     */
open func required() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestedfield_required(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the field retained status
     */
open func retained() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_requestedfield_retained(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestedField: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RequestedField

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RequestedField {
        return RequestedField(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RequestedField) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedField {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RequestedField, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedField_lift(_ pointer: UnsafeMutableRawPointer) throws -> RequestedField {
    return try FfiConverterTypeRequestedField.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedField_lower(_ value: RequestedField) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRequestedField.lower(value)
}






/**
 * A cryptographic keypair that can be used for signing.
 */
public protocol SigningKey: AnyObject, Sendable {
    
    /**
     * Generates a public JWK for this key.
     */
    func jwk() throws  -> String
    
    /**
     * Produces a signature of unknown encoding.
     */
    func sign(payload: Data) throws  -> Data
    
}
/**
 * A cryptographic keypair that can be used for signing.
 */
open class SigningKeyImpl: SigningKey, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_signingkey(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_signingkey(pointer, $0) }
    }

    

    
    /**
     * Generates a public JWK for this key.
     */
open func jwk()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeCryptoError_lift) {
    uniffi_mobile_sdk_rs_fn_method_signingkey_jwk(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Produces a signature of unknown encoding.
     */
open func sign(payload: Data)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeCryptoError_lift) {
    uniffi_mobile_sdk_rs_fn_method_signingkey_sign(self.uniffiClonePointer(),
        FfiConverterData.lower(payload),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSigningKey {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSigningKey] = [UniffiVTableCallbackInterfaceSigningKey(
        jwk: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> String in
                guard let uniffiObj = try? FfiConverterTypeSigningKey.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.jwk(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterString.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeCryptoError_lower
            )
        },
        sign: { (
            uniffiHandle: UInt64,
            payload: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Data in
                guard let uniffiObj = try? FfiConverterTypeSigningKey.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.sign(
                     payload: try FfiConverterData.lift(payload)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterData.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeCryptoError_lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeSigningKey.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SigningKey: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitSigningKey() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_signingkey(UniffiCallbackInterfaceSigningKey.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSigningKey: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<SigningKey>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SigningKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SigningKey {
        return SigningKeyImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SigningKey) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SigningKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SigningKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSigningKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> SigningKey {
    return try FfiConverterTypeSigningKey.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSigningKey_lower(_ value: SigningKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSigningKey.lower(value)
}






/**
 * Status provides a value and purpose for a status,
 *
 * The value is the raw value of the status at the entry list index,
 * and the purpose is the purpose of the credential, which is used
 * to interpret the value.
 */
public protocol StatusProtocol: AnyObject, Sendable {
    
    /**
     * Return whether the credential status has a message.
     */
    func isMessage()  -> Bool
    
    /**
     * Return whether the credential status is revoked.
     */
    func isRevoked()  -> Bool
    
    /**
     * Return whether the credential status is suspended.
     */
    func isSuspended()  -> Bool
    
    /**
     * Return the message of the credential status.
     */
    func messages()  -> [StatusMessage]
    
    /**
     * Return the purpose of the status.
     */
    func purpose()  -> BitStringStatusPurpose
    
}
/**
 * Status provides a value and purpose for a status,
 *
 * The value is the raw value of the status at the entry list index,
 * and the purpose is the purpose of the credential, which is used
 * to interpret the value.
 */
open class Status: StatusProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_status(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_status(pointer, $0) }
    }

    

    
    /**
     * Return whether the credential status has a message.
     */
open func isMessage() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status_is_message(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return whether the credential status is revoked.
     */
open func isRevoked() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status_is_revoked(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return whether the credential status is suspended.
     */
open func isSuspended() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status_is_suspended(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the message of the credential status.
     */
open func messages() -> [StatusMessage]  {
    return try!  FfiConverterSequenceTypeStatusMessage.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status_messages(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the purpose of the status.
     */
open func purpose() -> BitStringStatusPurpose  {
    return try!  FfiConverterTypeBitStringStatusPurpose_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status_purpose(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStatus: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Status

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Status {
        return Status(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Status) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Status {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Status, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStatus_lift(_ pointer: UnsafeMutableRawPointer) throws -> Status {
    return try FfiConverterTypeStatus.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStatus_lower(_ value: Status) -> UnsafeMutableRawPointer {
    return FfiConverterTypeStatus.lower(value)
}






/**
 * Status provides a value and purpose for a status,
 *
 * The value is the raw value of the status at the entry list index,
 * and the purpose is the purpose of the credential, which is used
 * to interpret the value.
 */
public protocol Status20240406Protocol: AnyObject, Sendable {
    
    /**
     * Return whether the credential status has a message.
     */
    func isMessage()  -> Bool
    
    /**
     * Return whether the credential status is revoked.
     */
    func isRevoked()  -> Bool
    
    /**
     * Return whether the credential status is suspended.
     */
    func isSuspended()  -> Bool
    
    /**
     * Return the message of the credential status.
     */
    func messages()  -> [StatusMessage]
    
    /**
     * Return the purpose of the status.
     */
    func purpose()  -> BitString20240406StatusPurpose
    
}
/**
 * Status provides a value and purpose for a status,
 *
 * The value is the raw value of the status at the entry list index,
 * and the purpose is the purpose of the credential, which is used
 * to interpret the value.
 */
open class Status20240406: Status20240406Protocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_status20240406(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_status20240406(pointer, $0) }
    }

    

    
    /**
     * Return whether the credential status has a message.
     */
open func isMessage() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status20240406_is_message(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return whether the credential status is revoked.
     */
open func isRevoked() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status20240406_is_revoked(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return whether the credential status is suspended.
     */
open func isSuspended() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status20240406_is_suspended(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the message of the credential status.
     */
open func messages() -> [StatusMessage]  {
    return try!  FfiConverterSequenceTypeStatusMessage.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status20240406_messages(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the purpose of the status.
     */
open func purpose() -> BitString20240406StatusPurpose  {
    return try!  FfiConverterTypeBitString20240406StatusPurpose_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_status20240406_purpose(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStatus20240406: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Status20240406

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Status20240406 {
        return Status20240406(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Status20240406) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Status20240406 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Status20240406, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStatus20240406_lift(_ pointer: UnsafeMutableRawPointer) throws -> Status20240406 {
    return try FfiConverterTypeStatus20240406.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStatus20240406_lower(_ value: Status20240406) -> UnsafeMutableRawPointer {
    return FfiConverterTypeStatus20240406.lower(value)
}






/**
 * Interface: StorageManagerInterface
 *
 * The StorageManagerInterface provides access to functions defined in Kotlin and Swift for
 * managing persistent storage on the device.
 *
 * When dealing with UniFFI exported functions and objects, this will need to be Boxed as:
 * Box<dyn StorageManagerInterface>
 *
 * We use the older callback_interface to keep the required version level of our Android API
 * low.
 */
public protocol StorageManagerInterface: AnyObject, Sendable {
    
    /**
     * Function: add
     *
     * Adds a key-value pair to storage.  Should the key already exist, the value will be
     * replaced
     *
     * Arguments:
     * key - The key to add
     * value - The value to add under the key.
     */
    func add(key: Key, value: Value) async throws 
    
    /**
     * Function: get
     *
     * Callback function pointer to native (kotlin/swift) code for
     * getting a key.
     */
    func get(key: Key) async throws  -> Value?
    
    /**
     * Function: list
     *
     * Callback function pointer for listing available keys.
     */
    func list() async throws  -> [Key]
    
    /**
     * Function: remove
     *
     * Callback function pointer to native (kotlin/swift) code for
     * removing a key.  This referenced function MUST be idempotent.  In
     * particular, it must treat removing a non-existent key as a normal and
     * expected circumstance, simply returning () and not an error.
     */
    func remove(key: Key) async throws 
    
}
/**
 * Interface: StorageManagerInterface
 *
 * The StorageManagerInterface provides access to functions defined in Kotlin and Swift for
 * managing persistent storage on the device.
 *
 * When dealing with UniFFI exported functions and objects, this will need to be Boxed as:
 * Box<dyn StorageManagerInterface>
 *
 * We use the older callback_interface to keep the required version level of our Android API
 * low.
 */
open class StorageManagerInterfaceImpl: StorageManagerInterface, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_storagemanagerinterface(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_storagemanagerinterface(pointer, $0) }
    }

    

    
    /**
     * Function: add
     *
     * Adds a key-value pair to storage.  Should the key already exist, the value will be
     * replaced
     *
     * Arguments:
     * key - The key to add
     * value - The value to add under the key.
     */
open func add(key: Key, value: Value)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_storagemanagerinterface_add(
                    self.uniffiClonePointer(),
                    FfiConverterTypeKey_lower(key),FfiConverterTypeValue_lower(value)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageManagerError_lift
        )
}
    
    /**
     * Function: get
     *
     * Callback function pointer to native (kotlin/swift) code for
     * getting a key.
     */
open func get(key: Key)async throws  -> Value?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_storagemanagerinterface_get(
                    self.uniffiClonePointer(),
                    FfiConverterTypeKey_lower(key)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeValue.lift,
            errorHandler: FfiConverterTypeStorageManagerError_lift
        )
}
    
    /**
     * Function: list
     *
     * Callback function pointer for listing available keys.
     */
open func list()async throws  -> [Key]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_storagemanagerinterface_list(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeKey.lift,
            errorHandler: FfiConverterTypeStorageManagerError_lift
        )
}
    
    /**
     * Function: remove
     *
     * Callback function pointer to native (kotlin/swift) code for
     * removing a key.  This referenced function MUST be idempotent.  In
     * particular, it must treat removing a non-existent key as a normal and
     * expected circumstance, simply returning () and not an error.
     */
open func remove(key: Key)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_storagemanagerinterface_remove(
                    self.uniffiClonePointer(),
                    FfiConverterTypeKey_lower(key)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeStorageManagerError_lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceStorageManagerInterface {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceStorageManagerInterface] = [UniffiVTableCallbackInterfaceStorageManagerInterface(
        add: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            value: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorageManagerInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.add(
                     key: try FfiConverterTypeKey_lift(key),
                     value: try FfiConverterTypeValue_lift(value)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageManagerError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        get: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Value? in
                guard let uniffiObj = try? FfiConverterTypeStorageManagerInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.get(
                     key: try FfiConverterTypeKey_lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Value?) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterOptionTypeValue.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageManagerError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        list: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> [Key] in
                guard let uniffiObj = try? FfiConverterTypeStorageManagerInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.list(
                )
            }

            let uniffiHandleSuccess = { (returnValue: [Key]) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterSequenceTypeKey.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageManagerError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        remove: { (
            uniffiHandle: UInt64,
            key: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeStorageManagerInterface.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.remove(
                     key: try FfiConverterTypeKey_lift(key)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeStorageManagerError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeStorageManagerInterface.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface StorageManagerInterface: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitStorageManagerInterface() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_storagemanagerinterface(UniffiCallbackInterfaceStorageManagerInterface.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageManagerInterface: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<StorageManagerInterface>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = StorageManagerInterface

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> StorageManagerInterface {
        return StorageManagerInterfaceImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: StorageManagerInterface) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageManagerInterface {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: StorageManagerInterface, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageManagerInterface_lift(_ pointer: UnsafeMutableRawPointer) throws -> StorageManagerInterface {
    return try FfiConverterTypeStorageManagerInterface.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageManagerInterface_lower(_ value: StorageManagerInterface) -> UnsafeMutableRawPointer {
    return FfiConverterTypeStorageManagerInterface.lower(value)
}






public protocol SyncHttpClient: AnyObject, Sendable {
    
    func httpClient(request: HttpRequest) throws  -> HttpResponse
    
}
open class SyncHttpClientImpl: SyncHttpClient, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_synchttpclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_synchttpclient(pointer, $0) }
    }

    

    
open func httpClient(request: HttpRequest)throws  -> HttpResponse  {
    return try  FfiConverterTypeHttpResponse_lift(try rustCallWithError(FfiConverterTypeHttpClientError_lift) {
    uniffi_mobile_sdk_rs_fn_method_synchttpclient_http_client(self.uniffiClonePointer(),
        FfiConverterTypeHttpRequest_lower(request),$0
    )
})
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSyncHttpClient {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSyncHttpClient] = [UniffiVTableCallbackInterfaceSyncHttpClient(
        httpClient: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> HttpResponse in
                guard let uniffiObj = try? FfiConverterTypeSyncHttpClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.httpClient(
                     request: try FfiConverterTypeHttpRequest_lift(request)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeHttpResponse_lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeHttpClientError_lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeSyncHttpClient.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface SyncHttpClient: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitSyncHttpClient() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_synchttpclient(UniffiCallbackInterfaceSyncHttpClient.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncHttpClient: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<SyncHttpClient>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SyncHttpClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncHttpClient {
        return SyncHttpClientImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SyncHttpClient) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncHttpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SyncHttpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncHttpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> SyncHttpClient {
    return try FfiConverterTypeSyncHttpClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncHttpClient_lower(_ value: SyncHttpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSyncHttpClient.lower(value)
}






public protocol TokenResponseProtocol: AnyObject, Sendable {
    
}
open class TokenResponse: TokenResponseProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_tokenresponse(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_tokenresponse(pointer, $0) }
    }

    

    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTokenResponse: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TokenResponse

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TokenResponse {
        return TokenResponse(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TokenResponse) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TokenResponse {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TokenResponse, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenResponse_lift(_ pointer: UnsafeMutableRawPointer) throws -> TokenResponse {
    return try FfiConverterTypeTokenResponse.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTokenResponse_lower(_ value: TokenResponse) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTokenResponse.lower(value)
}






public protocol Vcdm2SdJwtProtocol: AnyObject, Sendable {
    
    /**
     * Return the ID for the SdJwt instance.
     */
    func id()  -> Uuid
    
    /**
     * Return the key alias for the credential
     */
    func keyAlias()  -> KeyAlias?
    
    /**
     * Return the revealed claims as a UTF-8 encoded JSON string.
     */
    func revealedClaimsAsJsonString() throws  -> String
    
    /**
     * Returns the status of the credential, resolving the value in the status list,
     * along with the purpose of the status.
     */
    func status() async throws  -> [Status20240406]
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
    func type()  -> CredentialType
    
}
open class Vcdm2SdJwt: Vcdm2SdJwtProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_vcdm2sdjwt(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_vcdm2sdjwt(pointer, $0) }
    }

    
    /**
     * Create a new SdJwt instance from a compact SD-JWS string.
     */
public static func newFromCompactSdJwt(input: String)throws  -> Vcdm2SdJwt  {
    return try  FfiConverterTypeVCDM2SdJwt_lift(try rustCallWithError(FfiConverterTypeSdJwtError_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_vcdm2sdjwt_new_from_compact_sd_jwt(
        FfiConverterString.lower(input),$0
    )
})
}
    
    /**
     * Create a new SdJwt instance from a compact SD-JWS string with a provided key alias.
     */
public static func newFromCompactSdJwtWithKey(input: String, keyAlias: KeyAlias)throws  -> Vcdm2SdJwt  {
    return try  FfiConverterTypeVCDM2SdJwt_lift(try rustCallWithError(FfiConverterTypeSdJwtError_lift) {
    uniffi_mobile_sdk_rs_fn_constructor_vcdm2sdjwt_new_from_compact_sd_jwt_with_key(
        FfiConverterString.lower(input),
        FfiConverterTypeKeyAlias_lower(keyAlias),$0
    )
})
}
    

    
    /**
     * Return the ID for the SdJwt instance.
     */
open func id() -> Uuid  {
    return try!  FfiConverterTypeUuid_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_vcdm2sdjwt_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the key alias for the credential
     */
open func keyAlias() -> KeyAlias?  {
    return try!  FfiConverterOptionTypeKeyAlias.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_vcdm2sdjwt_key_alias(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Return the revealed claims as a UTF-8 encoded JSON string.
     */
open func revealedClaimsAsJsonString()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeSdJwtError_lift) {
    uniffi_mobile_sdk_rs_fn_method_vcdm2sdjwt_revealed_claims_as_json_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the status of the credential, resolving the value in the status list,
     * along with the purpose of the status.
     */
open func status()async throws  -> [Status20240406]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_vcdm2sdjwt_status(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeStatus20240406.lift,
            errorHandler: FfiConverterTypeStatusListError_lift
        )
}
    
    /**
     * The type of this credential. Note that if there is more than one type (i.e. `types()`
     * returns more than one value), then the types will be concatenated with a "+".
     */
open func type() -> CredentialType  {
    return try!  FfiConverterTypeCredentialType_lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_vcdm2sdjwt_type(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVCDM2SdJwt: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Vcdm2SdJwt

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Vcdm2SdJwt {
        return Vcdm2SdJwt(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Vcdm2SdJwt) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Vcdm2SdJwt {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Vcdm2SdJwt, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVCDM2SdJwt_lift(_ pointer: UnsafeMutableRawPointer) throws -> Vcdm2SdJwt {
    return try FfiConverterTypeVCDM2SdJwt.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVCDM2SdJwt_lower(_ value: Vcdm2SdJwt) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVCDM2SdJwt.lower(value)
}






/**
 * Verifiable Digital Credential Collection
 *
 * This is the main interface to credentials.
 */
public protocol VdcCollectionProtocol: AnyObject, Sendable {
    
    /**
     * Add a credential to the set.
     */
    func add(credential: Credential) async throws 
    
    /**
     * Get a list of all the credentials.
     */
    func allEntries() async throws  -> [Uuid]
    
    /**
     * Get a list of all the credentials that match a specified type.
     */
    func allEntriesByType(ctype: CredentialType) async throws  -> [Uuid]
    
    /**
     * Remove a credential from the store.
     */
    func delete(id: Uuid) async throws 
    
    /**
     * Dump the contents of the credential set to the logger.
     */
    func dump() async 
    
    /**
     * Get a credential from the store.
     */
    func get(id: Uuid) async throws  -> Credential?
    
}
/**
 * Verifiable Digital Credential Collection
 *
 * This is the main interface to credentials.
 */
open class VdcCollection: VdcCollectionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_vdccollection(self.pointer, $0) }
    }
    /**
     * Create a new credential set.
     */
public convenience init(engine: StorageManagerInterface) {
    let pointer =
        try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_vdccollection_new(
        FfiConverterTypeStorageManagerInterface_lower(engine),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_vdccollection(pointer, $0) }
    }

    

    
    /**
     * Add a credential to the set.
     */
open func add(credential: Credential)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_vdccollection_add(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCredential_lower(credential)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVdcCollectionError_lift
        )
}
    
    /**
     * Get a list of all the credentials.
     */
open func allEntries()async throws  -> [Uuid]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_vdccollection_all_entries(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUuid.lift,
            errorHandler: FfiConverterTypeVdcCollectionError_lift
        )
}
    
    /**
     * Get a list of all the credentials that match a specified type.
     */
open func allEntriesByType(ctype: CredentialType)async throws  -> [Uuid]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_vdccollection_all_entries_by_type(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCredentialType_lower(ctype)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUuid.lift,
            errorHandler: FfiConverterTypeVdcCollectionError_lift
        )
}
    
    /**
     * Remove a credential from the store.
     */
open func delete(id: Uuid)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_vdccollection_delete(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUuid_lower(id)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVdcCollectionError_lift
        )
}
    
    /**
     * Dump the contents of the credential set to the logger.
     */
open func dump()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_vdccollection_dump(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Get a credential from the store.
     */
open func get(id: Uuid)async throws  -> Credential?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_vdccollection_get(
                    self.uniffiClonePointer(),
                    FfiConverterTypeUuid_lower(id)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeCredential.lift,
            errorHandler: FfiConverterTypeVdcCollectionError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVdcCollection: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = VdcCollection

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> VdcCollection {
        return VdcCollection(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: VdcCollection) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VdcCollection {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: VdcCollection, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVdcCollection_lift(_ pointer: UnsafeMutableRawPointer) throws -> VdcCollection {
    return try FfiConverterTypeVdcCollection.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVdcCollection_lower(_ value: VdcCollection) -> UnsafeMutableRawPointer {
    return FfiConverterTypeVdcCollection.lower(value)
}






public protocol WalletServiceClientProtocol: AnyObject, Sendable {
    
    /**
     * Helper method to get an authorization header with the current token
     */
    func getAuthHeader() throws  -> String
    
    /**
     * Returns the current client ID (sub claim from JWT)
     */
    func getClientId()  -> String?
    
    /**
     * Get the current token
     */
    func getToken()  -> String?
    
    /**
     * Returns true if the current token is valid and not expired
     */
    func isTokenValid()  -> Bool
    
    func login(appAttestation: String) async throws  -> String
    
    /**
     * Get a nonce from the server that expires in 5 minutes and can only be used once
     */
    func nonce() async throws  -> String
    
}
open class WalletServiceClient: WalletServiceClientProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_mobile_sdk_rs_fn_clone_walletserviceclient(self.pointer, $0) }
    }
public convenience init(baseUrl: String) {
    let pointer =
        try! rustCall() {
    uniffi_mobile_sdk_rs_fn_constructor_walletserviceclient_new(
        FfiConverterString.lower(baseUrl),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_mobile_sdk_rs_fn_free_walletserviceclient(pointer, $0) }
    }

    

    
    /**
     * Helper method to get an authorization header with the current token
     */
open func getAuthHeader()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeWalletServiceError_lift) {
    uniffi_mobile_sdk_rs_fn_method_walletserviceclient_get_auth_header(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the current client ID (sub claim from JWT)
     */
open func getClientId() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_walletserviceclient_get_client_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the current token
     */
open func getToken() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_walletserviceclient_get_token(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns true if the current token is valid and not expired
     */
open func isTokenValid() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_method_walletserviceclient_is_token_valid(self.uniffiClonePointer(),$0
    )
})
}
    
open func login(appAttestation: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_walletserviceclient_login(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(appAttestation)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeWalletServiceError_lift
        )
}
    
    /**
     * Get a nonce from the server that expires in 5 minutes and can only be used once
     */
open func nonce()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_method_walletserviceclient_nonce(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeWalletServiceError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletServiceClient: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = WalletServiceClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> WalletServiceClient {
        return WalletServiceClient(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: WalletServiceClient) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletServiceClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: WalletServiceClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletServiceClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> WalletServiceClient {
    return try FfiConverterTypeWalletServiceClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletServiceClient_lower(_ value: WalletServiceClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWalletServiceClient.lower(value)
}




public struct ApprovedResponse180137 {
    public var credentialId: Uuid
    public var approvedFields: [FieldId180137]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(credentialId: Uuid, approvedFields: [FieldId180137]) {
        self.credentialId = credentialId
        self.approvedFields = approvedFields
    }
}

#if compiler(>=6)
extension ApprovedResponse180137: Sendable {}
#endif


extension ApprovedResponse180137: Equatable, Hashable {
    public static func ==(lhs: ApprovedResponse180137, rhs: ApprovedResponse180137) -> Bool {
        if lhs.credentialId != rhs.credentialId {
            return false
        }
        if lhs.approvedFields != rhs.approvedFields {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(credentialId)
        hasher.combine(approvedFields)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeApprovedResponse180137: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApprovedResponse180137 {
        return
            try ApprovedResponse180137(
                credentialId: FfiConverterTypeUuid.read(from: &buf), 
                approvedFields: FfiConverterSequenceTypeFieldId180137.read(from: &buf)
        )
    }

    public static func write(_ value: ApprovedResponse180137, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.credentialId, into: &buf)
        FfiConverterSequenceTypeFieldId180137.write(value.approvedFields, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeApprovedResponse180137_lift(_ buf: RustBuffer) throws -> ApprovedResponse180137 {
    return try FfiConverterTypeApprovedResponse180137.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeApprovedResponse180137_lower(_ value: ApprovedResponse180137) -> RustBuffer {
    return FfiConverterTypeApprovedResponse180137.lower(value)
}


public struct CheckStatusResponse {
    public var state: String
    public var openidCredentialOffer: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: String, openidCredentialOffer: String) {
        self.state = state
        self.openidCredentialOffer = openidCredentialOffer
    }
}

#if compiler(>=6)
extension CheckStatusResponse: Sendable {}
#endif


extension CheckStatusResponse: Equatable, Hashable {
    public static func ==(lhs: CheckStatusResponse, rhs: CheckStatusResponse) -> Bool {
        if lhs.state != rhs.state {
            return false
        }
        if lhs.openidCredentialOffer != rhs.openidCredentialOffer {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(state)
        hasher.combine(openidCredentialOffer)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCheckStatusResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckStatusResponse {
        return
            try CheckStatusResponse(
                state: FfiConverterString.read(from: &buf), 
                openidCredentialOffer: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CheckStatusResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.state, into: &buf)
        FfiConverterString.write(value.openidCredentialOffer, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckStatusResponse_lift(_ buf: RustBuffer) throws -> CheckStatusResponse {
    return try FfiConverterTypeCheckStatusResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckStatusResponse_lower(_ value: CheckStatusResponse) -> RustBuffer {
    return FfiConverterTypeCheckStatusResponse.lower(value)
}


/**
 * An unparsed credential, retrieved from storage.
 */
public struct Credential {
    /**
     * The local ID of this credential.
     */
    public var id: Uuid
    /**
     * The format of this credential.
     */
    public var format: CredentialFormat
    /**
     * The type of this credential.
     */
    public var type: CredentialType
    /**
     * The raw payload of this credential. The encoding depends on the format.
     */
    public var payload: Data
    /**
     * The alias of the key that is authorized to present this credential.
     */
    public var keyAlias: KeyAlias?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The local ID of this credential.
         */id: Uuid, 
        /**
         * The format of this credential.
         */format: CredentialFormat, 
        /**
         * The type of this credential.
         */type: CredentialType, 
        /**
         * The raw payload of this credential. The encoding depends on the format.
         */payload: Data, 
        /**
         * The alias of the key that is authorized to present this credential.
         */keyAlias: KeyAlias?) {
        self.id = id
        self.format = format
        self.type = type
        self.payload = payload
        self.keyAlias = keyAlias
    }
}

#if compiler(>=6)
extension Credential: Sendable {}
#endif


extension Credential: Equatable, Hashable {
    public static func ==(lhs: Credential, rhs: Credential) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.format != rhs.format {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.payload != rhs.payload {
            return false
        }
        if lhs.keyAlias != rhs.keyAlias {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(format)
        hasher.combine(type)
        hasher.combine(payload)
        hasher.combine(keyAlias)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Credential {
        return
            try Credential(
                id: FfiConverterTypeUuid.read(from: &buf), 
                format: FfiConverterTypeCredentialFormat.read(from: &buf), 
                type: FfiConverterTypeCredentialType.read(from: &buf), 
                payload: FfiConverterData.read(from: &buf), 
                keyAlias: FfiConverterOptionTypeKeyAlias.read(from: &buf)
        )
    }

    public static func write(_ value: Credential, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeCredentialFormat.write(value.format, into: &buf)
        FfiConverterTypeCredentialType.write(value.type, into: &buf)
        FfiConverterData.write(value.payload, into: &buf)
        FfiConverterOptionTypeKeyAlias.write(value.keyAlias, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredential_lift(_ buf: RustBuffer) throws -> Credential {
    return try FfiConverterTypeCredential.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredential_lower(_ value: Credential) -> RustBuffer {
    return FfiConverterTypeCredential.lower(value)
}


/**
 * Information about the verified credential.
 */
public struct CredentialInfo {
    /**
     * The credential title that should be displayed on the success screen.
     */
    public var title: String
    /**
     * The image that should be displayed on the success screen.
     */
    public var image: Data
    /**
     * The claims decoded from the credential.
     */
    public var claims: [String: ClaimValue]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The credential title that should be displayed on the success screen.
         */title: String, 
        /**
         * The image that should be displayed on the success screen.
         */image: Data, 
        /**
         * The claims decoded from the credential.
         */claims: [String: ClaimValue]) {
        self.title = title
        self.image = image
        self.claims = claims
    }
}

#if compiler(>=6)
extension CredentialInfo: Sendable {}
#endif


extension CredentialInfo: Equatable, Hashable {
    public static func ==(lhs: CredentialInfo, rhs: CredentialInfo) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.image != rhs.image {
            return false
        }
        if lhs.claims != rhs.claims {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(image)
        hasher.combine(claims)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentialInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialInfo {
        return
            try CredentialInfo(
                title: FfiConverterString.read(from: &buf), 
                image: FfiConverterData.read(from: &buf), 
                claims: FfiConverterDictionaryStringTypeClaimValue.read(from: &buf)
        )
    }

    public static func write(_ value: CredentialInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.title, into: &buf)
        FfiConverterData.write(value.image, into: &buf)
        FfiConverterDictionaryStringTypeClaimValue.write(value.claims, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialInfo_lift(_ buf: RustBuffer) throws -> CredentialInfo {
    return try FfiConverterTypeCredentialInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialInfo_lower(_ value: CredentialInfo) -> RustBuffer {
    return FfiConverterTypeCredentialInfo.lower(value)
}


public struct CredentialResponse {
    public var format: CredentialFormat
    public var payload: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(format: CredentialFormat, payload: Data) {
        self.format = format
        self.payload = payload
    }
}

#if compiler(>=6)
extension CredentialResponse: Sendable {}
#endif


extension CredentialResponse: Equatable, Hashable {
    public static func ==(lhs: CredentialResponse, rhs: CredentialResponse) -> Bool {
        if lhs.format != rhs.format {
            return false
        }
        if lhs.payload != rhs.payload {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(format)
        hasher.combine(payload)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentialResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialResponse {
        return
            try CredentialResponse(
                format: FfiConverterTypeCredentialFormat.read(from: &buf), 
                payload: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: CredentialResponse, into buf: inout [UInt8]) {
        FfiConverterTypeCredentialFormat.write(value.format, into: &buf)
        FfiConverterData.write(value.payload, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialResponse_lift(_ buf: RustBuffer) throws -> CredentialResponse {
    return try FfiConverterTypeCredentialResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialResponse_lower(_ value: CredentialResponse) -> RustBuffer {
    return FfiConverterTypeCredentialResponse.lower(value)
}


public struct DelegateInitializationResponse {
    /**
     * This is the authorization request URL to be presented in
     * a QR code to the holder.
     */
    public var authQuery: String
    /**
     * This is the status URL to check the presentation status
     * from the delegated verifier.
     */
    public var uri: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * This is the authorization request URL to be presented in
         * a QR code to the holder.
         */authQuery: String, 
        /**
         * This is the status URL to check the presentation status
         * from the delegated verifier.
         */uri: String) {
        self.authQuery = authQuery
        self.uri = uri
    }
}

#if compiler(>=6)
extension DelegateInitializationResponse: Sendable {}
#endif


extension DelegateInitializationResponse: Equatable, Hashable {
    public static func ==(lhs: DelegateInitializationResponse, rhs: DelegateInitializationResponse) -> Bool {
        if lhs.authQuery != rhs.authQuery {
            return false
        }
        if lhs.uri != rhs.uri {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(authQuery)
        hasher.combine(uri)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDelegateInitializationResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DelegateInitializationResponse {
        return
            try DelegateInitializationResponse(
                authQuery: FfiConverterString.read(from: &buf), 
                uri: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DelegateInitializationResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.authQuery, into: &buf)
        FfiConverterString.write(value.uri, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDelegateInitializationResponse_lift(_ buf: RustBuffer) throws -> DelegateInitializationResponse {
    return try FfiConverterTypeDelegateInitializationResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDelegateInitializationResponse_lower(_ value: DelegateInitializationResponse) -> RustBuffer {
    return FfiConverterTypeDelegateInitializationResponse.lower(value)
}


public struct DelegatedVerifierOid4vpResponse {
    /**
     * Presented SD-JWT.
     */
    public var vpToken: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Presented SD-JWT.
         */vpToken: String) {
        self.vpToken = vpToken
    }
}

#if compiler(>=6)
extension DelegatedVerifierOid4vpResponse: Sendable {}
#endif


extension DelegatedVerifierOid4vpResponse: Equatable, Hashable {
    public static func ==(lhs: DelegatedVerifierOid4vpResponse, rhs: DelegatedVerifierOid4vpResponse) -> Bool {
        if lhs.vpToken != rhs.vpToken {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(vpToken)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDelegatedVerifierOid4vpResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DelegatedVerifierOid4vpResponse {
        return
            try DelegatedVerifierOid4vpResponse(
                vpToken: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DelegatedVerifierOid4vpResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.vpToken, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDelegatedVerifierOid4vpResponse_lift(_ buf: RustBuffer) throws -> DelegatedVerifierOid4vpResponse {
    return try FfiConverterTypeDelegatedVerifierOid4vpResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDelegatedVerifierOid4vpResponse_lower(_ value: DelegatedVerifierOid4vpResponse) -> RustBuffer {
    return FfiConverterTypeDelegatedVerifierOid4vpResponse.lower(value)
}


public struct DelegatedVerifierStatusResponse {
    /**
     * The status of the verification request.
     */
    public var status: DelegatedVerifierStatus
    /**
     * OID4VP presentation
     */
    public var oid4vp: DelegatedVerifierOid4vpResponse?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The status of the verification request.
         */status: DelegatedVerifierStatus, 
        /**
         * OID4VP presentation
         */oid4vp: DelegatedVerifierOid4vpResponse?) {
        self.status = status
        self.oid4vp = oid4vp
    }
}

#if compiler(>=6)
extension DelegatedVerifierStatusResponse: Sendable {}
#endif


extension DelegatedVerifierStatusResponse: Equatable, Hashable {
    public static func ==(lhs: DelegatedVerifierStatusResponse, rhs: DelegatedVerifierStatusResponse) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.oid4vp != rhs.oid4vp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(oid4vp)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDelegatedVerifierStatusResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DelegatedVerifierStatusResponse {
        return
            try DelegatedVerifierStatusResponse(
                status: FfiConverterTypeDelegatedVerifierStatus.read(from: &buf), 
                oid4vp: FfiConverterOptionTypeDelegatedVerifierOid4vpResponse.read(from: &buf)
        )
    }

    public static func write(_ value: DelegatedVerifierStatusResponse, into buf: inout [UInt8]) {
        FfiConverterTypeDelegatedVerifierStatus.write(value.status, into: &buf)
        FfiConverterOptionTypeDelegatedVerifierOid4vpResponse.write(value.oid4vp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDelegatedVerifierStatusResponse_lift(_ buf: RustBuffer) throws -> DelegatedVerifierStatusResponse {
    return try FfiConverterTypeDelegatedVerifierStatusResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDelegatedVerifierStatusResponse_lower(_ value: DelegatedVerifierStatusResponse) -> RustBuffer {
    return FfiConverterTypeDelegatedVerifierStatusResponse.lower(value)
}


/**
 * Simple representation of an mdoc data element.
 */
public struct Element {
    /**
     * Name of the data element.
     */
    public var identifier: String
    /**
     * JSON representation of the data element, missing if the value cannot be represented as JSON.
     */
    public var value: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Name of the data element.
         */identifier: String, 
        /**
         * JSON representation of the data element, missing if the value cannot be represented as JSON.
         */value: String?) {
        self.identifier = identifier
        self.value = value
    }
}

#if compiler(>=6)
extension Element: Sendable {}
#endif


extension Element: Equatable, Hashable {
    public static func ==(lhs: Element, rhs: Element) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeElement: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Element {
        return
            try Element(
                identifier: FfiConverterString.read(from: &buf), 
                value: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Element, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifier, into: &buf)
        FfiConverterOptionString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeElement_lift(_ buf: RustBuffer) throws -> Element {
    return try FfiConverterTypeElement.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeElement_lower(_ value: Element) -> RustBuffer {
    return FfiConverterTypeElement.lower(value)
}


/**
 * A verification failure with a code and reason.
 */
public struct Failure {
    public var code: UInt64
    public var reason: String
    public var details: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(code: UInt64, reason: String, details: String) {
        self.code = code
        self.reason = reason
        self.details = details
    }
}

#if compiler(>=6)
extension Failure: Sendable {}
#endif


extension Failure: Equatable, Hashable {
    public static func ==(lhs: Failure, rhs: Failure) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.details != rhs.details {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(reason)
        hasher.combine(details)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFailure: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Failure {
        return
            try Failure(
                code: FfiConverterUInt64.read(from: &buf), 
                reason: FfiConverterString.read(from: &buf), 
                details: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Failure, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.code, into: &buf)
        FfiConverterString.write(value.reason, into: &buf)
        FfiConverterString.write(value.details, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFailure_lift(_ buf: RustBuffer) throws -> Failure {
    return try FfiConverterTypeFailure.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFailure_lower(_ value: Failure) -> RustBuffer {
    return FfiConverterTypeFailure.lower(value)
}


/**
 * Plain Rust object representation of an HttpRequest that can be exported
 * through `uniffi` and is used in `WithForeign` trait definitions for HTTP
 * clients.
 */
public struct HttpRequest {
    public var url: String
    public var method: String
    public var headers: [String: String]
    public var body: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, method: String, headers: [String: String], body: Data) {
        self.url = url
        self.method = method
        self.headers = headers
        self.body = body
    }
}

#if compiler(>=6)
extension HttpRequest: Sendable {}
#endif


extension HttpRequest: Equatable, Hashable {
    public static func ==(lhs: HttpRequest, rhs: HttpRequest) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(method)
        hasher.combine(headers)
        hasher.combine(body)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHttpRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpRequest {
        return
            try HttpRequest(
                url: FfiConverterString.read(from: &buf), 
                method: FfiConverterString.read(from: &buf), 
                headers: FfiConverterDictionaryStringString.read(from: &buf), 
                body: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: HttpRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterString.write(value.method, into: &buf)
        FfiConverterDictionaryStringString.write(value.headers, into: &buf)
        FfiConverterData.write(value.body, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpRequest_lift(_ buf: RustBuffer) throws -> HttpRequest {
    return try FfiConverterTypeHttpRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpRequest_lower(_ value: HttpRequest) -> RustBuffer {
    return FfiConverterTypeHttpRequest.lower(value)
}


/**
 * Plain Rust object representation of an HttpResponse that can be exported
 * through `uniffi` and is used in `WithForeign` trait definitions for HTTP
 * clients.
 */
public struct HttpResponse {
    public var statusCode: UInt16
    public var headers: [String: String]
    public var body: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(statusCode: UInt16, headers: [String: String], body: Data) {
        self.statusCode = statusCode
        self.headers = headers
        self.body = body
    }
}

#if compiler(>=6)
extension HttpResponse: Sendable {}
#endif


extension HttpResponse: Equatable, Hashable {
    public static func ==(lhs: HttpResponse, rhs: HttpResponse) -> Bool {
        if lhs.statusCode != rhs.statusCode {
            return false
        }
        if lhs.headers != rhs.headers {
            return false
        }
        if lhs.body != rhs.body {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(statusCode)
        hasher.combine(headers)
        hasher.combine(body)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHttpResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpResponse {
        return
            try HttpResponse(
                statusCode: FfiConverterUInt16.read(from: &buf), 
                headers: FfiConverterDictionaryStringString.read(from: &buf), 
                body: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: HttpResponse, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.statusCode, into: &buf)
        FfiConverterDictionaryStringString.write(value.headers, into: &buf)
        FfiConverterData.write(value.body, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpResponse_lift(_ buf: RustBuffer) throws -> HttpResponse {
    return try FfiConverterTypeHttpResponse.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpResponse_lower(_ value: HttpResponse) -> RustBuffer {
    return FfiConverterTypeHttpResponse.lower(value)
}


public struct ItemsRequest {
    public var docType: String
    public var namespaces: [String: [String: Bool]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(docType: String, namespaces: [String: [String: Bool]]) {
        self.docType = docType
        self.namespaces = namespaces
    }
}

#if compiler(>=6)
extension ItemsRequest: Sendable {}
#endif


extension ItemsRequest: Equatable, Hashable {
    public static func ==(lhs: ItemsRequest, rhs: ItemsRequest) -> Bool {
        if lhs.docType != rhs.docType {
            return false
        }
        if lhs.namespaces != rhs.namespaces {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(docType)
        hasher.combine(namespaces)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeItemsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ItemsRequest {
        return
            try ItemsRequest(
                docType: FfiConverterString.read(from: &buf), 
                namespaces: FfiConverterDictionaryStringDictionaryStringBool.read(from: &buf)
        )
    }

    public static func write(_ value: ItemsRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.docType, into: &buf)
        FfiConverterDictionaryStringDictionaryStringBool.write(value.namespaces, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeItemsRequest_lift(_ buf: RustBuffer) throws -> ItemsRequest {
    return try FfiConverterTypeItemsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeItemsRequest_lower(_ value: ItemsRequest) -> RustBuffer {
    return FfiConverterTypeItemsRequest.lower(value)
}


public struct MdlReaderResponseData {
    public var state: MdlSessionManager
    /**
     * Contains the namespaces for the mDL directly, without top-level doc types
     */
    public var verifiedResponse: [String: [String: MDocItem]]
    /**
     * Outcome of issuer authentication.
     */
    public var issuerAuthentication: AuthenticationStatus
    /**
     * Outcome of device authentication.
     */
    public var deviceAuthentication: AuthenticationStatus
    /**
     * Errors that occurred during response processing.
     */
    public var errors: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: MdlSessionManager, 
        /**
         * Contains the namespaces for the mDL directly, without top-level doc types
         */verifiedResponse: [String: [String: MDocItem]], 
        /**
         * Outcome of issuer authentication.
         */issuerAuthentication: AuthenticationStatus, 
        /**
         * Outcome of device authentication.
         */deviceAuthentication: AuthenticationStatus, 
        /**
         * Errors that occurred during response processing.
         */errors: String?) {
        self.state = state
        self.verifiedResponse = verifiedResponse
        self.issuerAuthentication = issuerAuthentication
        self.deviceAuthentication = deviceAuthentication
        self.errors = errors
    }
}

#if compiler(>=6)
extension MdlReaderResponseData: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMDLReaderResponseData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlReaderResponseData {
        return
            try MdlReaderResponseData(
                state: FfiConverterTypeMDLSessionManager.read(from: &buf), 
                verifiedResponse: FfiConverterDictionaryStringDictionaryStringTypeMDocItem.read(from: &buf), 
                issuerAuthentication: FfiConverterTypeAuthenticationStatus.read(from: &buf), 
                deviceAuthentication: FfiConverterTypeAuthenticationStatus.read(from: &buf), 
                errors: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: MdlReaderResponseData, into buf: inout [UInt8]) {
        FfiConverterTypeMDLSessionManager.write(value.state, into: &buf)
        FfiConverterDictionaryStringDictionaryStringTypeMDocItem.write(value.verifiedResponse, into: &buf)
        FfiConverterTypeAuthenticationStatus.write(value.issuerAuthentication, into: &buf)
        FfiConverterTypeAuthenticationStatus.write(value.deviceAuthentication, into: &buf)
        FfiConverterOptionString.write(value.errors, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDLReaderResponseData_lift(_ buf: RustBuffer) throws -> MdlReaderResponseData {
    return try FfiConverterTypeMDLReaderResponseData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDLReaderResponseData_lower(_ value: MdlReaderResponseData) -> RustBuffer {
    return FfiConverterTypeMDLReaderResponseData.lower(value)
}


public struct MdlReaderSessionData {
    public var state: MdlSessionManager
    public var uuid: Uuid
    public var request: Data
    public var bleIdent: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: MdlSessionManager, uuid: Uuid, request: Data, bleIdent: Data) {
        self.state = state
        self.uuid = uuid
        self.request = request
        self.bleIdent = bleIdent
    }
}

#if compiler(>=6)
extension MdlReaderSessionData: Sendable {}
#endif



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMDLReaderSessionData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlReaderSessionData {
        return
            try MdlReaderSessionData(
                state: FfiConverterTypeMDLSessionManager.read(from: &buf), 
                uuid: FfiConverterTypeUuid.read(from: &buf), 
                request: FfiConverterData.read(from: &buf), 
                bleIdent: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: MdlReaderSessionData, into buf: inout [UInt8]) {
        FfiConverterTypeMDLSessionManager.write(value.state, into: &buf)
        FfiConverterTypeUuid.write(value.uuid, into: &buf)
        FfiConverterData.write(value.request, into: &buf)
        FfiConverterData.write(value.bleIdent, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDLReaderSessionData_lift(_ buf: RustBuffer) throws -> MdlReaderSessionData {
    return try FfiConverterTypeMDLReaderSessionData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDLReaderSessionData_lower(_ value: MdlReaderSessionData) -> RustBuffer {
    return FfiConverterTypeMDLReaderSessionData.lower(value)
}


public struct Oid4vciExchangeOptions {
    public var verifyAfterExchange: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(verifyAfterExchange: Bool?) {
        self.verifyAfterExchange = verifyAfterExchange
    }
}

#if compiler(>=6)
extension Oid4vciExchangeOptions: Sendable {}
#endif


extension Oid4vciExchangeOptions: Equatable, Hashable {
    public static func ==(lhs: Oid4vciExchangeOptions, rhs: Oid4vciExchangeOptions) -> Bool {
        if lhs.verifyAfterExchange != rhs.verifyAfterExchange {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(verifyAfterExchange)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOid4vciExchangeOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vciExchangeOptions {
        return
            try Oid4vciExchangeOptions(
                verifyAfterExchange: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: Oid4vciExchangeOptions, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.verifyAfterExchange, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOid4vciExchangeOptions_lift(_ buf: RustBuffer) throws -> Oid4vciExchangeOptions {
    return try FfiConverterTypeOid4vciExchangeOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOid4vciExchangeOptions_lower(_ value: Oid4vciExchangeOptions) -> RustBuffer {
    return FfiConverterTypeOid4vciExchangeOptions.lower(value)
}


public struct RequestedField180137 {
    public var id: FieldId180137
    public var displayableName: String
    public var displayableValue: String?
    public var selectivelyDisclosable: Bool
    public var intentToRetain: Bool
    public var required: Bool
    public var purpose: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: FieldId180137, displayableName: String, displayableValue: String?, selectivelyDisclosable: Bool, intentToRetain: Bool, required: Bool, purpose: String?) {
        self.id = id
        self.displayableName = displayableName
        self.displayableValue = displayableValue
        self.selectivelyDisclosable = selectivelyDisclosable
        self.intentToRetain = intentToRetain
        self.required = required
        self.purpose = purpose
    }
}

#if compiler(>=6)
extension RequestedField180137: Sendable {}
#endif


extension RequestedField180137: Equatable, Hashable {
    public static func ==(lhs: RequestedField180137, rhs: RequestedField180137) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.displayableName != rhs.displayableName {
            return false
        }
        if lhs.displayableValue != rhs.displayableValue {
            return false
        }
        if lhs.selectivelyDisclosable != rhs.selectivelyDisclosable {
            return false
        }
        if lhs.intentToRetain != rhs.intentToRetain {
            return false
        }
        if lhs.required != rhs.required {
            return false
        }
        if lhs.purpose != rhs.purpose {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(displayableName)
        hasher.combine(displayableValue)
        hasher.combine(selectivelyDisclosable)
        hasher.combine(intentToRetain)
        hasher.combine(required)
        hasher.combine(purpose)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestedField180137: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestedField180137 {
        return
            try RequestedField180137(
                id: FfiConverterTypeFieldId180137.read(from: &buf), 
                displayableName: FfiConverterString.read(from: &buf), 
                displayableValue: FfiConverterOptionString.read(from: &buf), 
                selectivelyDisclosable: FfiConverterBool.read(from: &buf), 
                intentToRetain: FfiConverterBool.read(from: &buf), 
                required: FfiConverterBool.read(from: &buf), 
                purpose: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: RequestedField180137, into buf: inout [UInt8]) {
        FfiConverterTypeFieldId180137.write(value.id, into: &buf)
        FfiConverterString.write(value.displayableName, into: &buf)
        FfiConverterOptionString.write(value.displayableValue, into: &buf)
        FfiConverterBool.write(value.selectivelyDisclosable, into: &buf)
        FfiConverterBool.write(value.intentToRetain, into: &buf)
        FfiConverterBool.write(value.required, into: &buf)
        FfiConverterOptionString.write(value.purpose, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedField180137_lift(_ buf: RustBuffer) throws -> RequestedField180137 {
    return try FfiConverterTypeRequestedField180137.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestedField180137_lower(_ value: RequestedField180137) -> RustBuffer {
    return FfiConverterTypeRequestedField180137.lower(value)
}


/**
 * Non-normative response options used to provide configurable interface
 * for handling variations in the processing of the verifiable presentation
 * payloads in various external verifiers.
 */
public struct ResponseOptions {
    /**
     * This is an non-normative setting to determine
     * the behavior of removing extra quotations around a JSON
     * string encoded vp_token, e.g. "'[{ @context: [...] }]'" -> '[{ @context: [...] }]'
     */
    public var shouldStripQuotes: Bool
    /**
     * Boolean option of whether to use `array_or_value` serialization options
     * for the verifiable presentation.
     *
     * This is provided as an option to force serializing a single verifiable
     * credential as a member of an array, versus as a singular option, per
     * implementation.
     *
     * NOTE: This may be removed in the future as the oid4vp specification becomes
     * more solidified around `vp_token` presentation.
     *
     * These options are provided as configurable parameters to maintain backwards
     * compatibility with verifier implementation versions.
     */
    public var forceArraySerialization: Bool
    /**
     * Remove the `$.vp` path prefix for the descriptor map for the verifiable credential.
     * This is non-normative option, e.g. `$.vp` -> `$`
     */
    public var removeVpPathPrefix: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * This is an non-normative setting to determine
         * the behavior of removing extra quotations around a JSON
         * string encoded vp_token, e.g. "'[{ @context: [...] }]'" -> '[{ @context: [...] }]'
         */shouldStripQuotes: Bool, 
        /**
         * Boolean option of whether to use `array_or_value` serialization options
         * for the verifiable presentation.
         *
         * This is provided as an option to force serializing a single verifiable
         * credential as a member of an array, versus as a singular option, per
         * implementation.
         *
         * NOTE: This may be removed in the future as the oid4vp specification becomes
         * more solidified around `vp_token` presentation.
         *
         * These options are provided as configurable parameters to maintain backwards
         * compatibility with verifier implementation versions.
         */forceArraySerialization: Bool, 
        /**
         * Remove the `$.vp` path prefix for the descriptor map for the verifiable credential.
         * This is non-normative option, e.g. `$.vp` -> `$`
         */removeVpPathPrefix: Bool) {
        self.shouldStripQuotes = shouldStripQuotes
        self.forceArraySerialization = forceArraySerialization
        self.removeVpPathPrefix = removeVpPathPrefix
    }
}

#if compiler(>=6)
extension ResponseOptions: Sendable {}
#endif


extension ResponseOptions: Equatable, Hashable {
    public static func ==(lhs: ResponseOptions, rhs: ResponseOptions) -> Bool {
        if lhs.shouldStripQuotes != rhs.shouldStripQuotes {
            return false
        }
        if lhs.forceArraySerialization != rhs.forceArraySerialization {
            return false
        }
        if lhs.removeVpPathPrefix != rhs.removeVpPathPrefix {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(shouldStripQuotes)
        hasher.combine(forceArraySerialization)
        hasher.combine(removeVpPathPrefix)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResponseOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResponseOptions {
        return
            try ResponseOptions(
                shouldStripQuotes: FfiConverterBool.read(from: &buf), 
                forceArraySerialization: FfiConverterBool.read(from: &buf), 
                removeVpPathPrefix: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ResponseOptions, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.shouldStripQuotes, into: &buf)
        FfiConverterBool.write(value.forceArraySerialization, into: &buf)
        FfiConverterBool.write(value.removeVpPathPrefix, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResponseOptions_lift(_ buf: RustBuffer) throws -> ResponseOptions {
    return try FfiConverterTypeResponseOptions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResponseOptions_lower(_ value: ResponseOptions) -> RustBuffer {
    return FfiConverterTypeResponseOptions.lower(value)
}


public struct StatusMessage {
    /**
     * The value of the entry in the status list
     */
    public var status: UInt8
    /**
     * Message that corresponds the the value.
     */
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The value of the entry in the status list
         */status: UInt8, 
        /**
         * Message that corresponds the the value.
         */message: String) {
        self.status = status
        self.message = message
    }
}

#if compiler(>=6)
extension StatusMessage: Sendable {}
#endif


extension StatusMessage: Equatable, Hashable {
    public static func ==(lhs: StatusMessage, rhs: StatusMessage) -> Bool {
        if lhs.status != rhs.status {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(status)
        hasher.combine(message)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStatusMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StatusMessage {
        return
            try StatusMessage(
                status: FfiConverterUInt8.read(from: &buf), 
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: StatusMessage, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.status, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStatusMessage_lift(_ buf: RustBuffer) throws -> StatusMessage {
    return try FfiConverterTypeStatusMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStatusMessage_lower(_ value: StatusMessage) -> RustBuffer {
    return FfiConverterTypeStatusMessage.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AuthenticationStatus {
    
    case valid
    case invalid
    case unchecked
}


#if compiler(>=6)
extension AuthenticationStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthenticationStatus: FfiConverterRustBuffer {
    typealias SwiftType = AuthenticationStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthenticationStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .valid
        
        case 2: return .invalid
        
        case 3: return .unchecked
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthenticationStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .valid:
            writeInt(&buf, Int32(1))
        
        
        case .invalid:
            writeInt(&buf, Int32(2))
        
        
        case .unchecked:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthenticationStatus_lift(_ buf: RustBuffer) throws -> AuthenticationStatus {
    return try FfiConverterTypeAuthenticationStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthenticationStatus_lower(_ value: AuthenticationStatus) -> RustBuffer {
    return FfiConverterTypeAuthenticationStatus.lower(value)
}


extension AuthenticationStatus: Equatable, Hashable {}




public enum CborLdEncodingError: Swift.Error {

    
    
    case JsonParse(String
    )
    case CborEncode(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCborLdEncodingError: FfiConverterRustBuffer {
    typealias SwiftType = CborLdEncodingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CborLdEncodingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .JsonParse(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .CborEncode(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CborLdEncodingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .JsonParse(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CborEncode(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCborLdEncodingError_lift(_ buf: RustBuffer) throws -> CborLdEncodingError {
    return try FfiConverterTypeCborLdEncodingError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCborLdEncodingError_lower(_ value: CborLdEncodingError) -> RustBuffer {
    return FfiConverterTypeCborLdEncodingError.lower(value)
}


extension CborLdEncodingError: Equatable, Hashable {}



extension CborLdEncodingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CborValue {
    
    case null
    case bool(Bool
    )
    case integer(CborInteger
    )
    case float(Double
    )
    case bytes(Data
    )
    case text(String
    )
    case array([CborValue]
    )
    case itemMap([String: CborValue]
    )
    case tag(CborTag
    )
}


#if compiler(>=6)
extension CborValue: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCborValue: FfiConverterRustBuffer {
    typealias SwiftType = CborValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CborValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .null
        
        case 2: return .bool(try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .integer(try FfiConverterTypeCborInteger.read(from: &buf)
        )
        
        case 4: return .float(try FfiConverterDouble.read(from: &buf)
        )
        
        case 5: return .bytes(try FfiConverterData.read(from: &buf)
        )
        
        case 6: return .text(try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .array(try FfiConverterSequenceTypeCborValue.read(from: &buf)
        )
        
        case 8: return .itemMap(try FfiConverterDictionaryStringTypeCborValue.read(from: &buf)
        )
        
        case 9: return .tag(try FfiConverterTypeCborTag.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CborValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case .null:
            writeInt(&buf, Int32(1))
        
        
        case let .bool(v1):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(v1, into: &buf)
            
        
        case let .integer(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeCborInteger.write(v1, into: &buf)
            
        
        case let .float(v1):
            writeInt(&buf, Int32(4))
            FfiConverterDouble.write(v1, into: &buf)
            
        
        case let .bytes(v1):
            writeInt(&buf, Int32(5))
            FfiConverterData.write(v1, into: &buf)
            
        
        case let .text(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .array(v1):
            writeInt(&buf, Int32(7))
            FfiConverterSequenceTypeCborValue.write(v1, into: &buf)
            
        
        case let .itemMap(v1):
            writeInt(&buf, Int32(8))
            FfiConverterDictionaryStringTypeCborValue.write(v1, into: &buf)
            
        
        case let .tag(v1):
            writeInt(&buf, Int32(9))
            FfiConverterTypeCborTag.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCborValue_lift(_ buf: RustBuffer) throws -> CborValue {
    return try FfiConverterTypeCborValue.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCborValue_lower(_ value: CborValue) -> RustBuffer {
    return FfiConverterTypeCborValue.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Credential claim values.
 */

public enum ClaimValue {
    
    /**
     * Any text claim that doesn't need special formatting.
     */
    case text(value: String
    )
    /**
     * A date claim in the format `[year]-[month]-[day]`.
     */
    case date(value: String
    )
    /**
     * MapArray
     */
    case mapClaim(value: [String: String]
    )
}


#if compiler(>=6)
extension ClaimValue: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClaimValue: FfiConverterRustBuffer {
    typealias SwiftType = ClaimValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClaimValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text(value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .date(value: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .mapClaim(value: try FfiConverterDictionaryStringString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClaimValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .text(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .date(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .mapClaim(value):
            writeInt(&buf, Int32(3))
            FfiConverterDictionaryStringString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimValue_lift(_ buf: RustBuffer) throws -> ClaimValue {
    return try FfiConverterTypeClaimValue.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClaimValue_lower(_ value: ClaimValue) -> RustBuffer {
    return FfiConverterTypeClaimValue.lower(value)
}


extension ClaimValue: Equatable, Hashable {}




public enum CredentialDecodingError: Swift.Error {

    
    
    case MsoMdoc(MdocInitError
    )
    case JsonVc(JsonVcInitError
    )
    case JwtVc(JwtVcInitError
    )
    case SdJwt(SdJwtError
    )
    case Cwt(CwtError
    )
    case UnsupportedCredentialFormat(String
    )
    case Serialization(String
    )
    case Deserialization(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentialDecodingError: FfiConverterRustBuffer {
    typealias SwiftType = CredentialDecodingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialDecodingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MsoMdoc(
            try FfiConverterTypeMdocInitError.read(from: &buf)
            )
        case 2: return .JsonVc(
            try FfiConverterTypeJsonVcInitError.read(from: &buf)
            )
        case 3: return .JwtVc(
            try FfiConverterTypeJwtVcInitError.read(from: &buf)
            )
        case 4: return .SdJwt(
            try FfiConverterTypeSdJwtError.read(from: &buf)
            )
        case 5: return .Cwt(
            try FfiConverterTypeCwtError.read(from: &buf)
            )
        case 6: return .UnsupportedCredentialFormat(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .Serialization(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .Deserialization(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CredentialDecodingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .MsoMdoc(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMdocInitError.write(v1, into: &buf)
            
        
        case let .JsonVc(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeJsonVcInitError.write(v1, into: &buf)
            
        
        case let .JwtVc(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeJwtVcInitError.write(v1, into: &buf)
            
        
        case let .SdJwt(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeSdJwtError.write(v1, into: &buf)
            
        
        case let .Cwt(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeCwtError.write(v1, into: &buf)
            
        
        case let .UnsupportedCredentialFormat(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Serialization(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Deserialization(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialDecodingError_lift(_ buf: RustBuffer) throws -> CredentialDecodingError {
    return try FfiConverterTypeCredentialDecodingError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialDecodingError_lower(_ value: CredentialDecodingError) -> RustBuffer {
    return FfiConverterTypeCredentialDecodingError.lower(value)
}


extension CredentialDecodingError: Equatable, Hashable {}



extension CredentialDecodingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum CredentialEncodingError: Swift.Error {

    
    
    case MsoMdoc(MdocEncodingError
    )
    case JsonVc(JsonVcEncodingError
    )
    case SdJwt(SdJwtError
    )
    case VpToken(String
    )
    case Presentation(PresentationError
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentialEncodingError: FfiConverterRustBuffer {
    typealias SwiftType = CredentialEncodingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialEncodingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MsoMdoc(
            try FfiConverterTypeMdocEncodingError.read(from: &buf)
            )
        case 2: return .JsonVc(
            try FfiConverterTypeJsonVcEncodingError.read(from: &buf)
            )
        case 3: return .SdJwt(
            try FfiConverterTypeSdJwtError.read(from: &buf)
            )
        case 4: return .VpToken(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .Presentation(
            try FfiConverterTypePresentationError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CredentialEncodingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .MsoMdoc(v1):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMdocEncodingError.write(v1, into: &buf)
            
        
        case let .JsonVc(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeJsonVcEncodingError.write(v1, into: &buf)
            
        
        case let .SdJwt(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeSdJwtError.write(v1, into: &buf)
            
        
        case let .VpToken(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Presentation(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypePresentationError.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialEncodingError_lift(_ buf: RustBuffer) throws -> CredentialEncodingError {
    return try FfiConverterTypeCredentialEncodingError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialEncodingError_lower(_ value: CredentialEncodingError) -> RustBuffer {
    return FfiConverterTypeCredentialEncodingError.lower(value)
}


extension CredentialEncodingError: Equatable, Hashable {}



extension CredentialEncodingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The format of the credential.
 */

public enum CredentialFormat {
    
    case msoMdoc
    case jwtVcJson
    case jwtVcJsonLd
    case ldpVc
    case vcdm2SdJwt
    case cwt
    case other(String
    )
}


#if compiler(>=6)
extension CredentialFormat: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentialFormat: FfiConverterRustBuffer {
    typealias SwiftType = CredentialFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .msoMdoc
        
        case 2: return .jwtVcJson
        
        case 3: return .jwtVcJsonLd
        
        case 4: return .ldpVc
        
        case 5: return .vcdm2SdJwt
        
        case 6: return .cwt
        
        case 7: return .other(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CredentialFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .msoMdoc:
            writeInt(&buf, Int32(1))
        
        
        case .jwtVcJson:
            writeInt(&buf, Int32(2))
        
        
        case .jwtVcJsonLd:
            writeInt(&buf, Int32(3))
        
        
        case .ldpVc:
            writeInt(&buf, Int32(4))
        
        
        case .vcdm2SdJwt:
            writeInt(&buf, Int32(5))
        
        
        case .cwt:
            writeInt(&buf, Int32(6))
        
        
        case let .other(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialFormat_lift(_ buf: RustBuffer) throws -> CredentialFormat {
    return try FfiConverterTypeCredentialFormat.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialFormat_lower(_ value: CredentialFormat) -> RustBuffer {
    return FfiConverterTypeCredentialFormat.lower(value)
}


extension CredentialFormat: Equatable, Hashable {}




public enum CredentialPresentationError: Swift.Error {

    
    
    case Decoding(String
    )
    case JsonPath(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentialPresentationError: FfiConverterRustBuffer {
    typealias SwiftType = CredentialPresentationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialPresentationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Decoding(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .JsonPath(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CredentialPresentationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Decoding(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .JsonPath(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialPresentationError_lift(_ buf: RustBuffer) throws -> CredentialPresentationError {
    return try FfiConverterTypeCredentialPresentationError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialPresentationError_lower(_ value: CredentialPresentationError) -> RustBuffer {
    return FfiConverterTypeCredentialPresentationError.lower(value)
}


extension CredentialPresentationError: Equatable, Hashable {}



extension CredentialPresentationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum CryptoError: Swift.Error {

    
    
    case General(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCryptoError: FfiConverterRustBuffer {
    typealias SwiftType = CryptoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CryptoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .General(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CryptoError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .General(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCryptoError_lift(_ buf: RustBuffer) throws -> CryptoError {
    return try FfiConverterTypeCryptoError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCryptoError_lower(_ value: CryptoError) -> RustBuffer {
    return FfiConverterTypeCryptoError.lower(value)
}


extension CryptoError: Equatable, Hashable {}



extension CryptoError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum CwtError: Swift.Error {

    
    
    case CompactJwsDecoding
    case CwsPayloadDecode(String
    )
    case Base10Decode
    case Decompression(String
    )
    case CborDecoding(String
    )
    case ClaimsRetrieval(String
    )
    case EmptyPayload
    case IncorrectCredential(String,String
    )
    case MissingClaim(String
    )
    case MalformedClaim(String,String,String
    )
    case Trust(String
    )
    case CwtExpired(String
    )
    case LoadRootCertificate(String
    )
    case Internal
    case CwtSignatureVerification(String
    )
    case SignerCertificateInvalid(String
    )
    case SignerCertificateMismatch(String,String
    )
    case RootCertificateInvalid(String
    )
    case UnableToEncodeSignerCertificateAsDer
    case UnableToEncodeRootCertificateAsDer
    case UnableToExtractExtensionsFromSignerCertificate
    case RootCertificateExpired
    case SignerCertificateExpired
    case UnableToExtractExtensionsFromRootCertificate
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCwtError: FfiConverterRustBuffer {
    typealias SwiftType = CwtError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CwtError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CompactJwsDecoding
        case 2: return .CwsPayloadDecode(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .Base10Decode
        case 4: return .Decompression(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .CborDecoding(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .ClaimsRetrieval(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .EmptyPayload
        case 8: return .IncorrectCredential(
            try FfiConverterString.read(from: &buf), 
            try FfiConverterString.read(from: &buf)
            )
        case 9: return .MissingClaim(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .MalformedClaim(
            try FfiConverterString.read(from: &buf), 
            try FfiConverterString.read(from: &buf), 
            try FfiConverterString.read(from: &buf)
            )
        case 11: return .Trust(
            try FfiConverterString.read(from: &buf)
            )
        case 12: return .CwtExpired(
            try FfiConverterString.read(from: &buf)
            )
        case 13: return .LoadRootCertificate(
            try FfiConverterString.read(from: &buf)
            )
        case 14: return .Internal
        case 15: return .CwtSignatureVerification(
            try FfiConverterString.read(from: &buf)
            )
        case 16: return .SignerCertificateInvalid(
            try FfiConverterString.read(from: &buf)
            )
        case 17: return .SignerCertificateMismatch(
            try FfiConverterString.read(from: &buf), 
            try FfiConverterString.read(from: &buf)
            )
        case 18: return .RootCertificateInvalid(
            try FfiConverterString.read(from: &buf)
            )
        case 19: return .UnableToEncodeSignerCertificateAsDer
        case 20: return .UnableToEncodeRootCertificateAsDer
        case 21: return .UnableToExtractExtensionsFromSignerCertificate
        case 22: return .RootCertificateExpired
        case 23: return .SignerCertificateExpired
        case 24: return .UnableToExtractExtensionsFromRootCertificate

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CwtError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .CompactJwsDecoding:
            writeInt(&buf, Int32(1))
        
        
        case let .CwsPayloadDecode(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .Base10Decode:
            writeInt(&buf, Int32(3))
        
        
        case let .Decompression(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CborDecoding(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ClaimsRetrieval(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .EmptyPayload:
            writeInt(&buf, Int32(7))
        
        
        case let .IncorrectCredential(v1,v2):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            FfiConverterString.write(v2, into: &buf)
            
        
        case let .MissingClaim(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .MalformedClaim(v1,v2,v3):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            FfiConverterString.write(v2, into: &buf)
            FfiConverterString.write(v3, into: &buf)
            
        
        case let .Trust(v1):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CwtExpired(v1):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .LoadRootCertificate(v1):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .Internal:
            writeInt(&buf, Int32(14))
        
        
        case let .CwtSignatureVerification(v1):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .SignerCertificateInvalid(v1):
            writeInt(&buf, Int32(16))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .SignerCertificateMismatch(v1,v2):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(v1, into: &buf)
            FfiConverterString.write(v2, into: &buf)
            
        
        case let .RootCertificateInvalid(v1):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .UnableToEncodeSignerCertificateAsDer:
            writeInt(&buf, Int32(19))
        
        
        case .UnableToEncodeRootCertificateAsDer:
            writeInt(&buf, Int32(20))
        
        
        case .UnableToExtractExtensionsFromSignerCertificate:
            writeInt(&buf, Int32(21))
        
        
        case .RootCertificateExpired:
            writeInt(&buf, Int32(22))
        
        
        case .SignerCertificateExpired:
            writeInt(&buf, Int32(23))
        
        
        case .UnableToExtractExtensionsFromRootCertificate:
            writeInt(&buf, Int32(24))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCwtError_lift(_ buf: RustBuffer) throws -> CwtError {
    return try FfiConverterTypeCwtError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCwtError_lower(_ value: CwtError) -> RustBuffer {
    return FfiConverterTypeCwtError.lower(value)
}


extension CwtError: Equatable, Hashable {}



extension CwtError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum DcApiError: Swift.Error {

    
    
    case InvalidRequest(String
    )
    case InternalError(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDcApiError: FfiConverterRustBuffer {
    typealias SwiftType = DcApiError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DcApiError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidRequest(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InternalError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DcApiError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidRequest(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InternalError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDcApiError_lift(_ buf: RustBuffer) throws -> DcApiError {
    return try FfiConverterTypeDcApiError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDcApiError_lower(_ value: DcApiError) -> RustBuffer {
    return FfiConverterTypeDcApiError.lower(value)
}


extension DcApiError: Equatable, Hashable {}



extension DcApiError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DelegatedVerifierStatus {
    
    case initiated
    case pending
    case failure
    case success
}


#if compiler(>=6)
extension DelegatedVerifierStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDelegatedVerifierStatus: FfiConverterRustBuffer {
    typealias SwiftType = DelegatedVerifierStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DelegatedVerifierStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initiated
        
        case 2: return .pending
        
        case 3: return .failure
        
        case 4: return .success
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DelegatedVerifierStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initiated:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case .failure:
            writeInt(&buf, Int32(3))
        
        
        case .success:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDelegatedVerifierStatus_lift(_ buf: RustBuffer) throws -> DelegatedVerifierStatus {
    return try FfiConverterTypeDelegatedVerifierStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDelegatedVerifierStatus_lower(_ value: DelegatedVerifierStatus) -> RustBuffer {
    return FfiConverterTypeDelegatedVerifierStatus.lower(value)
}


extension DelegatedVerifierStatus: Equatable, Hashable {}




public enum DidError: Swift.Error {

    
    
    case SerializationError(message: String)
    
    case GenerateError(message: String)
    
    case ResolutionError(message: String)
    
    case MissingVerificationMethod(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDidError: FfiConverterRustBuffer {
    typealias SwiftType = DidError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DidError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SerializationError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .GenerateError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .ResolutionError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .MissingVerificationMethod(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DidError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .SerializationError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .GenerateError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .ResolutionError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .MissingVerificationMethod(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDidError_lift(_ buf: RustBuffer) throws -> DidError {
    return try FfiConverterTypeDidError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDidError_lower(_ value: DidError) -> RustBuffer {
    return FfiConverterTypeDidError.lower(value)
}


extension DidError: Equatable, Hashable {}



extension DidError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DidMethod {
    
    case jwk
    case key
}


#if compiler(>=6)
extension DidMethod: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDidMethod: FfiConverterRustBuffer {
    typealias SwiftType = DidMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DidMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .jwk
        
        case 2: return .key
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DidMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .jwk:
            writeInt(&buf, Int32(1))
        
        
        case .key:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDidMethod_lift(_ buf: RustBuffer) throws -> DidMethod {
    return try FfiConverterTypeDidMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDidMethod_lower(_ value: DidMethod) -> RustBuffer {
    return FfiConverterTypeDidMethod.lower(value)
}


extension DidMethod: Equatable, Hashable {}




public enum HttpClientError: Swift.Error {

    
    
    case RequestBuilder
    case ResponseBuilder
    case UrlParse
    case MethodParse
    case HeaderParse
    case HeaderKeyParse(key: String
    )
    case HeaderValueParse(value: String
    )
    case HeaderEntryParse(key: String, value: String
    )
    case Other(error: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHttpClientError: FfiConverterRustBuffer {
    typealias SwiftType = HttpClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .RequestBuilder
        case 2: return .ResponseBuilder
        case 3: return .UrlParse
        case 4: return .MethodParse
        case 5: return .HeaderParse
        case 6: return .HeaderKeyParse(
            key: try FfiConverterString.read(from: &buf)
            )
        case 7: return .HeaderValueParse(
            value: try FfiConverterString.read(from: &buf)
            )
        case 8: return .HeaderEntryParse(
            key: try FfiConverterString.read(from: &buf), 
            value: try FfiConverterString.read(from: &buf)
            )
        case 9: return .Other(
            error: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HttpClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .RequestBuilder:
            writeInt(&buf, Int32(1))
        
        
        case .ResponseBuilder:
            writeInt(&buf, Int32(2))
        
        
        case .UrlParse:
            writeInt(&buf, Int32(3))
        
        
        case .MethodParse:
            writeInt(&buf, Int32(4))
        
        
        case .HeaderParse:
            writeInt(&buf, Int32(5))
        
        
        case let .HeaderKeyParse(key):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(key, into: &buf)
            
        
        case let .HeaderValueParse(value):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .HeaderEntryParse(key,value):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
            
        
        case let .Other(error):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpClientError_lift(_ buf: RustBuffer) throws -> HttpClientError {
    return try FfiConverterTypeHttpClientError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpClientError_lower(_ value: HttpClientError) -> RustBuffer {
    return FfiConverterTypeHttpClientError.lower(value)
}


extension HttpClientError: Equatable, Hashable {}



extension HttpClientError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



/**
 * Represents errors that may occur during issuance operations
 */
public enum IssuanceServiceError: Swift.Error {

    
    
    /**
     * Failed to send the request to the server
     */
    case NetworkError(String
    )
    /**
     * Server returned an error response
     */
    case ServerError(status: UInt16, errorMessage: String
    )
    /**
     * Failed to read the response body
     */
    case ResponseError(String
    )
    /**
     * Invalid wallet attestation
     */
    case InvalidAttestation(String
    )
    /**
     * Internal error
     */
    case InternalError(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIssuanceServiceError: FfiConverterRustBuffer {
    typealias SwiftType = IssuanceServiceError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IssuanceServiceError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NetworkError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .ServerError(
            status: try FfiConverterUInt16.read(from: &buf), 
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 3: return .ResponseError(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .InvalidAttestation(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .InternalError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: IssuanceServiceError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .NetworkError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ServerError(status,errorMessage):
            writeInt(&buf, Int32(2))
            FfiConverterUInt16.write(status, into: &buf)
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .ResponseError(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidAttestation(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InternalError(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIssuanceServiceError_lift(_ buf: RustBuffer) throws -> IssuanceServiceError {
    return try FfiConverterTypeIssuanceServiceError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIssuanceServiceError_lower(_ value: IssuanceServiceError) -> RustBuffer {
    return FfiConverterTypeIssuanceServiceError.lower(value)
}


extension IssuanceServiceError: Equatable, Hashable {}



extension IssuanceServiceError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum JsonVcEncodingError: Swift.Error {

    
    
    case JsonBytesEncoding
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJsonVcEncodingError: FfiConverterRustBuffer {
    typealias SwiftType = JsonVcEncodingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonVcEncodingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .JsonBytesEncoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JsonVcEncodingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .JsonBytesEncoding:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsonVcEncodingError_lift(_ buf: RustBuffer) throws -> JsonVcEncodingError {
    return try FfiConverterTypeJsonVcEncodingError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsonVcEncodingError_lower(_ value: JsonVcEncodingError) -> RustBuffer {
    return FfiConverterTypeJsonVcEncodingError.lower(value)
}


extension JsonVcEncodingError: Equatable, Hashable {}



extension JsonVcEncodingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum JsonVcInitError: Swift.Error {

    
    
    case CredentialDecoding
    case CredentialStringEncoding
    case JsonBytesDecoding
    case JsonStringDecoding
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJsonVcInitError: FfiConverterRustBuffer {
    typealias SwiftType = JsonVcInitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonVcInitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CredentialDecoding
        case 2: return .CredentialStringEncoding
        case 3: return .JsonBytesDecoding
        case 4: return .JsonStringDecoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JsonVcInitError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .CredentialDecoding:
            writeInt(&buf, Int32(1))
        
        
        case .CredentialStringEncoding:
            writeInt(&buf, Int32(2))
        
        
        case .JsonBytesDecoding:
            writeInt(&buf, Int32(3))
        
        
        case .JsonStringDecoding:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsonVcInitError_lift(_ buf: RustBuffer) throws -> JsonVcInitError {
    return try FfiConverterTypeJsonVcInitError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsonVcInitError_lower(_ value: JsonVcInitError) -> RustBuffer {
    return FfiConverterTypeJsonVcInitError.lower(value)
}


extension JsonVcInitError: Equatable, Hashable {}



extension JsonVcInitError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum JwtVcInitError: Swift.Error {

    
    
    case CompactJwsDecoding
    case CredentialClaimDecoding
    case CredentialClaimMissing
    case CredentialStringEncoding
    case JwsBytesDecoding
    case JwtDecoding
    case HeaderDecoding
    case PayloadDecoding
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJwtVcInitError: FfiConverterRustBuffer {
    typealias SwiftType = JwtVcInitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JwtVcInitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CompactJwsDecoding
        case 2: return .CredentialClaimDecoding
        case 3: return .CredentialClaimMissing
        case 4: return .CredentialStringEncoding
        case 5: return .JwsBytesDecoding
        case 6: return .JwtDecoding
        case 7: return .HeaderDecoding
        case 8: return .PayloadDecoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JwtVcInitError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .CompactJwsDecoding:
            writeInt(&buf, Int32(1))
        
        
        case .CredentialClaimDecoding:
            writeInt(&buf, Int32(2))
        
        
        case .CredentialClaimMissing:
            writeInt(&buf, Int32(3))
        
        
        case .CredentialStringEncoding:
            writeInt(&buf, Int32(4))
        
        
        case .JwsBytesDecoding:
            writeInt(&buf, Int32(5))
        
        
        case .JwtDecoding:
            writeInt(&buf, Int32(6))
        
        
        case .HeaderDecoding:
            writeInt(&buf, Int32(7))
        
        
        case .PayloadDecoding:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJwtVcInitError_lift(_ buf: RustBuffer) throws -> JwtVcInitError {
    return try FfiConverterTypeJwtVcInitError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJwtVcInitError_lower(_ value: JwtVcInitError) -> RustBuffer {
    return FfiConverterTypeJwtVcInitError.lower(value)
}


extension JwtVcInitError: Equatable, Hashable {}



extension JwtVcInitError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum KeyTransformationError: Swift.Error {

    
    
    case ToPkcs8(value: String
    )
    case FromPkcs8(value: String
    )
    case FromSec1(value: String
    )
    case ToSec1(value: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyTransformationError: FfiConverterRustBuffer {
    typealias SwiftType = KeyTransformationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyTransformationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ToPkcs8(
            value: try FfiConverterString.read(from: &buf)
            )
        case 2: return .FromPkcs8(
            value: try FfiConverterString.read(from: &buf)
            )
        case 3: return .FromSec1(
            value: try FfiConverterString.read(from: &buf)
            )
        case 4: return .ToSec1(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeyTransformationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ToPkcs8(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .FromPkcs8(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .FromSec1(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .ToSec1(value):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyTransformationError_lift(_ buf: RustBuffer) throws -> KeyTransformationError {
    return try FfiConverterTypeKeyTransformationError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyTransformationError_lower(_ value: KeyTransformationError) -> RustBuffer {
    return FfiConverterTypeKeyTransformationError.lower(value)
}


extension KeyTransformationError: Equatable, Hashable {}



extension KeyTransformationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum MdlReaderResponseError: Swift.Error {

    
    
    case InvalidDecryption
    case InvalidParsing
    case InvalidIssuerAuthentication
    case InvalidDeviceAuthentication
    case Generic(value: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMDLReaderResponseError: FfiConverterRustBuffer {
    typealias SwiftType = MdlReaderResponseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlReaderResponseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidDecryption
        case 2: return .InvalidParsing
        case 3: return .InvalidIssuerAuthentication
        case 4: return .InvalidDeviceAuthentication
        case 5: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdlReaderResponseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidDecryption:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidParsing:
            writeInt(&buf, Int32(2))
        
        
        case .InvalidIssuerAuthentication:
            writeInt(&buf, Int32(3))
        
        
        case .InvalidDeviceAuthentication:
            writeInt(&buf, Int32(4))
        
        
        case let .Generic(value):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDLReaderResponseError_lift(_ buf: RustBuffer) throws -> MdlReaderResponseError {
    return try FfiConverterTypeMDLReaderResponseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDLReaderResponseError_lower(_ value: MdlReaderResponseError) -> RustBuffer {
    return FfiConverterTypeMDLReaderResponseError.lower(value)
}


extension MdlReaderResponseError: Equatable, Hashable {}



extension MdlReaderResponseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum MdlReaderResponseSerializeError: Swift.Error {

    
    
    case Generic(value: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMDLReaderResponseSerializeError: FfiConverterRustBuffer {
    typealias SwiftType = MdlReaderResponseSerializeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlReaderResponseSerializeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdlReaderResponseSerializeError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDLReaderResponseSerializeError_lift(_ buf: RustBuffer) throws -> MdlReaderResponseSerializeError {
    return try FfiConverterTypeMDLReaderResponseSerializeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDLReaderResponseSerializeError_lower(_ value: MdlReaderResponseSerializeError) -> RustBuffer {
    return FfiConverterTypeMDLReaderResponseSerializeError.lower(value)
}


extension MdlReaderResponseSerializeError: Equatable, Hashable {}



extension MdlReaderResponseSerializeError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum MdlReaderSessionError: Swift.Error {

    
    
    case Generic(value: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMDLReaderSessionError: FfiConverterRustBuffer {
    typealias SwiftType = MdlReaderSessionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlReaderSessionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdlReaderSessionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDLReaderSessionError_lift(_ buf: RustBuffer) throws -> MdlReaderSessionError {
    return try FfiConverterTypeMDLReaderSessionError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDLReaderSessionError_lower(_ value: MdlReaderSessionError) -> RustBuffer {
    return FfiConverterTypeMDLReaderSessionError.lower(value)
}


extension MdlReaderSessionError: Equatable, Hashable {}



extension MdlReaderSessionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MDocItem {
    
    case text(String
    )
    case bool(Bool
    )
    case integer(Int64
    )
    case itemMap([String: MDocItem]
    )
    case array([MDocItem]
    )
}


#if compiler(>=6)
extension MDocItem: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMDocItem: FfiConverterRustBuffer {
    typealias SwiftType = MDocItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MDocItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .bool(try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .integer(try FfiConverterInt64.read(from: &buf)
        )
        
        case 4: return .itemMap(try FfiConverterDictionaryStringTypeMDocItem.read(from: &buf)
        )
        
        case 5: return .array(try FfiConverterSequenceTypeMDocItem.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MDocItem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .text(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .bool(v1):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(v1, into: &buf)
            
        
        case let .integer(v1):
            writeInt(&buf, Int32(3))
            FfiConverterInt64.write(v1, into: &buf)
            
        
        case let .itemMap(v1):
            writeInt(&buf, Int32(4))
            FfiConverterDictionaryStringTypeMDocItem.write(v1, into: &buf)
            
        
        case let .array(v1):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeMDocItem.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDocItem_lift(_ buf: RustBuffer) throws -> MDocItem {
    return try FfiConverterTypeMDocItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMDocItem_lower(_ value: MDocItem) -> RustBuffer {
    return FfiConverterTypeMDocItem.lower(value)
}


extension MDocItem: Equatable, Hashable {}




public enum MdlUtilError: Swift.Error {

    
    
    case General(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMdlUtilError: FfiConverterRustBuffer {
    typealias SwiftType = MdlUtilError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdlUtilError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .General(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdlUtilError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .General(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdlUtilError_lift(_ buf: RustBuffer) throws -> MdlUtilError {
    return try FfiConverterTypeMdlUtilError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdlUtilError_lower(_ value: MdlUtilError) -> RustBuffer {
    return FfiConverterTypeMdlUtilError.lower(value)
}


extension MdlUtilError: Equatable, Hashable {}



extension MdlUtilError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum MdocEncodingError: Swift.Error {

    
    
    case DocumentCborEncoding
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMdocEncodingError: FfiConverterRustBuffer {
    typealias SwiftType = MdocEncodingError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdocEncodingError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DocumentCborEncoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdocEncodingError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .DocumentCborEncoding:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdocEncodingError_lift(_ buf: RustBuffer) throws -> MdocEncodingError {
    return try FfiConverterTypeMdocEncodingError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdocEncodingError_lower(_ value: MdocEncodingError) -> RustBuffer {
    return FfiConverterTypeMdocEncodingError.lower(value)
}


extension MdocEncodingError: Equatable, Hashable {}



extension MdocEncodingError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum MdocInitError: Swift.Error {

    
    
    case DocumentCborDecoding(String
    )
    case IssuerSignedBase64UrlDecoding
    case IssuerSignedCborDecoding
    case IssuerAuthPayloadMissing
    case IssuerAuthPayloadDecoding
    case KeyAliasMissing
    case NamespacesMissing
    case DocumentUtf8Decoding
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMdocInitError: FfiConverterRustBuffer {
    typealias SwiftType = MdocInitError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdocInitError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DocumentCborDecoding(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .IssuerSignedBase64UrlDecoding
        case 3: return .IssuerSignedCborDecoding
        case 4: return .IssuerAuthPayloadMissing
        case 5: return .IssuerAuthPayloadDecoding
        case 6: return .KeyAliasMissing
        case 7: return .NamespacesMissing
        case 8: return .DocumentUtf8Decoding

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdocInitError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .DocumentCborDecoding(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .IssuerSignedBase64UrlDecoding:
            writeInt(&buf, Int32(2))
        
        
        case .IssuerSignedCborDecoding:
            writeInt(&buf, Int32(3))
        
        
        case .IssuerAuthPayloadMissing:
            writeInt(&buf, Int32(4))
        
        
        case .IssuerAuthPayloadDecoding:
            writeInt(&buf, Int32(5))
        
        
        case .KeyAliasMissing:
            writeInt(&buf, Int32(6))
        
        
        case .NamespacesMissing:
            writeInt(&buf, Int32(7))
        
        
        case .DocumentUtf8Decoding:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdocInitError_lift(_ buf: RustBuffer) throws -> MdocInitError {
    return try FfiConverterTypeMdocInitError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdocInitError_lower(_ value: MdocInitError) -> RustBuffer {
    return FfiConverterTypeMdocInitError.lower(value)
}


extension MdocInitError: Equatable, Hashable {}



extension MdocInitError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum Oid4vp180137Error: Swift.Error {

    
    
    case Initialization(String
    )
    case InvalidRequest(String
    )
    case ResponseProcessing(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOID4VP180137Error: FfiConverterRustBuffer {
    typealias SwiftType = Oid4vp180137Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vp180137Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Initialization(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidRequest(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .ResponseProcessing(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Oid4vp180137Error, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Initialization(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidRequest(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ResponseProcessing(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOID4VP180137Error_lift(_ buf: RustBuffer) throws -> Oid4vp180137Error {
    return try FfiConverterTypeOID4VP180137Error.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOID4VP180137Error_lower(_ value: Oid4vp180137Error) -> RustBuffer {
    return FfiConverterTypeOID4VP180137Error.lower(value)
}


extension Oid4vp180137Error: Equatable, Hashable {}



extension Oid4vp180137Error: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



/**
 * The [OID4VPError] enum represents the errors that can occur
 * when using the oid4vp foreign library.
 */
public enum Oid4vpError: Swift.Error {

    
    
    case UnexpectedUniFfiCallbackError(String
    )
    case RequestValidation(String
    )
    case PresentationDefinitionResolution(String
    )
    case Token(String
    )
    case UnsupportedResponseMode(String
    )
    case ResponseSubmission(String
    )
    case CredentialCallback(String
    )
    case PresentationSubmissionCreation(String
    )
    case InvalidDidUrl(String
    )
    case DidKeyGenerateUrl(String
    )
    case JsonSyntaxParse(String
    )
    case VdcCollection(VdcCollectionError
    )
    case HttpClientInitialization(String
    )
    case SigningAlgorithmNotFound(String
    )
    case InvalidClientIdScheme(String
    )
    case InputDescriptorNotFound
    case VpTokenParse(String
    )
    case VpTokenCreate(String
    )
    case JwkParse(String
    )
    case VdcCollectionNotInitialized
    case AuthorizationRequestNotFound
    case RequestSignerNotFound
    case MetadataInitialization(String
    )
    case PermissionRequest(PermissionRequestError
    )
    case Presentation(PresentationError
    )
    case CredentialEncoding(CredentialEncodingError
    )
    case JsonPathParse(String
    )
    case JsonPathResolve(String
    )
    case JsonPathToPointer(String
    )
    case LimitDisclosure(String
    )
    case EmptyCredentialSubject(String
    )
    case SelectiveDisclosureInvalidFields
    case SelectiveDisclosureEmptySelection
    case Debug(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOID4VPError: FfiConverterRustBuffer {
    typealias SwiftType = Oid4vpError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vpError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .UnexpectedUniFfiCallbackError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .RequestValidation(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .PresentationDefinitionResolution(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .Token(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .UnsupportedResponseMode(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .ResponseSubmission(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .CredentialCallback(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .PresentationSubmissionCreation(
            try FfiConverterString.read(from: &buf)
            )
        case 9: return .InvalidDidUrl(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .DidKeyGenerateUrl(
            try FfiConverterString.read(from: &buf)
            )
        case 11: return .JsonSyntaxParse(
            try FfiConverterString.read(from: &buf)
            )
        case 12: return .VdcCollection(
            try FfiConverterTypeVdcCollectionError.read(from: &buf)
            )
        case 13: return .HttpClientInitialization(
            try FfiConverterString.read(from: &buf)
            )
        case 14: return .SigningAlgorithmNotFound(
            try FfiConverterString.read(from: &buf)
            )
        case 15: return .InvalidClientIdScheme(
            try FfiConverterString.read(from: &buf)
            )
        case 16: return .InputDescriptorNotFound
        case 17: return .VpTokenParse(
            try FfiConverterString.read(from: &buf)
            )
        case 18: return .VpTokenCreate(
            try FfiConverterString.read(from: &buf)
            )
        case 19: return .JwkParse(
            try FfiConverterString.read(from: &buf)
            )
        case 20: return .VdcCollectionNotInitialized
        case 21: return .AuthorizationRequestNotFound
        case 22: return .RequestSignerNotFound
        case 23: return .MetadataInitialization(
            try FfiConverterString.read(from: &buf)
            )
        case 24: return .PermissionRequest(
            try FfiConverterTypePermissionRequestError.read(from: &buf)
            )
        case 25: return .Presentation(
            try FfiConverterTypePresentationError.read(from: &buf)
            )
        case 26: return .CredentialEncoding(
            try FfiConverterTypeCredentialEncodingError.read(from: &buf)
            )
        case 27: return .JsonPathParse(
            try FfiConverterString.read(from: &buf)
            )
        case 28: return .JsonPathResolve(
            try FfiConverterString.read(from: &buf)
            )
        case 29: return .JsonPathToPointer(
            try FfiConverterString.read(from: &buf)
            )
        case 30: return .LimitDisclosure(
            try FfiConverterString.read(from: &buf)
            )
        case 31: return .EmptyCredentialSubject(
            try FfiConverterString.read(from: &buf)
            )
        case 32: return .SelectiveDisclosureInvalidFields
        case 33: return .SelectiveDisclosureEmptySelection
        case 34: return .Debug(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Oid4vpError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .UnexpectedUniFfiCallbackError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .RequestValidation(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .PresentationDefinitionResolution(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Token(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .UnsupportedResponseMode(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ResponseSubmission(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CredentialCallback(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .PresentationSubmissionCreation(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidDidUrl(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .DidKeyGenerateUrl(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .JsonSyntaxParse(v1):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .VdcCollection(v1):
            writeInt(&buf, Int32(12))
            FfiConverterTypeVdcCollectionError.write(v1, into: &buf)
            
        
        case let .HttpClientInitialization(v1):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .SigningAlgorithmNotFound(v1):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidClientIdScheme(v1):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .InputDescriptorNotFound:
            writeInt(&buf, Int32(16))
        
        
        case let .VpTokenParse(v1):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .VpTokenCreate(v1):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .JwkParse(v1):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .VdcCollectionNotInitialized:
            writeInt(&buf, Int32(20))
        
        
        case .AuthorizationRequestNotFound:
            writeInt(&buf, Int32(21))
        
        
        case .RequestSignerNotFound:
            writeInt(&buf, Int32(22))
        
        
        case let .MetadataInitialization(v1):
            writeInt(&buf, Int32(23))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .PermissionRequest(v1):
            writeInt(&buf, Int32(24))
            FfiConverterTypePermissionRequestError.write(v1, into: &buf)
            
        
        case let .Presentation(v1):
            writeInt(&buf, Int32(25))
            FfiConverterTypePresentationError.write(v1, into: &buf)
            
        
        case let .CredentialEncoding(v1):
            writeInt(&buf, Int32(26))
            FfiConverterTypeCredentialEncodingError.write(v1, into: &buf)
            
        
        case let .JsonPathParse(v1):
            writeInt(&buf, Int32(27))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .JsonPathResolve(v1):
            writeInt(&buf, Int32(28))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .JsonPathToPointer(v1):
            writeInt(&buf, Int32(29))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .LimitDisclosure(v1):
            writeInt(&buf, Int32(30))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .EmptyCredentialSubject(v1):
            writeInt(&buf, Int32(31))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .SelectiveDisclosureInvalidFields:
            writeInt(&buf, Int32(32))
        
        
        case .SelectiveDisclosureEmptySelection:
            writeInt(&buf, Int32(33))
        
        
        case let .Debug(v1):
            writeInt(&buf, Int32(34))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOID4VPError_lift(_ buf: RustBuffer) throws -> Oid4vpError {
    return try FfiConverterTypeOID4VPError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOID4VPError_lower(_ value: Oid4vpError) -> RustBuffer {
    return FfiConverterTypeOID4VPError.lower(value)
}


extension Oid4vpError: Equatable, Hashable {}



extension Oid4vpError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum Oid4vciError: Swift.Error {

    
    
    case SerdeJsonError(message: String)
    
    case RequestError(message: String)
    
    case UnsupportedGrantType(message: String)
    
    case InvalidSession(message: String)
    
    case InvalidParameter(message: String)
    
    case LockError(message: String)
    
    case VpRequestRequired(message: String)
    
    case ProofValidationError(message: String)
    
    case DecodeError(message: String)
    
    case DidError(message: String)
    
    case ContextMapError(message: String)
    
    case Generic(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOid4vciError: FfiConverterRustBuffer {
    typealias SwiftType = Oid4vciError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vciError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SerdeJsonError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .RequestError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .UnsupportedGrantType(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvalidSession(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidParameter(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .LockError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .VpRequestRequired(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .ProofValidationError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .DecodeError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .DidError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .ContextMapError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Oid4vciError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .SerdeJsonError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .RequestError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .UnsupportedGrantType(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .InvalidSession(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvalidParameter(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .LockError(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .VpRequestRequired(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .ProofValidationError(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .DecodeError(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .DidError(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .ContextMapError(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(12))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOid4vciError_lift(_ buf: RustBuffer) throws -> Oid4vciError {
    return try FfiConverterTypeOid4vciError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOid4vciError_lower(_ value: Oid4vciError) -> RustBuffer {
    return FfiConverterTypeOid4vciError.lower(value)
}


extension Oid4vciError: Equatable, Hashable {}



extension Oid4vciError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum Oid4vpVerifierError: Swift.Error {

    
    
    case HttpClient(String
    )
    case Url(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOid4vpVerifierError: FfiConverterRustBuffer {
    typealias SwiftType = Oid4vpVerifierError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Oid4vpVerifierError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .HttpClient(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Url(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Oid4vpVerifierError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .HttpClient(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Url(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOid4vpVerifierError_lift(_ buf: RustBuffer) throws -> Oid4vpVerifierError {
    return try FfiConverterTypeOid4vpVerifierError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOid4vpVerifierError_lower(_ value: Oid4vpVerifierError) -> RustBuffer {
    return FfiConverterTypeOid4vpVerifierError.lower(value)
}


extension Oid4vpVerifierError: Equatable, Hashable {}



extension Oid4vpVerifierError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The outcome of attempting to verify a credential.
 */

public enum Outcome {
    
    /**
     * The credential was successfully verified.
     */
    case verified(credentialInfo: CredentialInfo
    )
    /**
     * The credential could not be verified.
     */
    case unverified(credentialInfo: CredentialInfo?, failure: Failure
    )
}


#if compiler(>=6)
extension Outcome: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOutcome: FfiConverterRustBuffer {
    typealias SwiftType = Outcome

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Outcome {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .verified(credentialInfo: try FfiConverterTypeCredentialInfo.read(from: &buf)
        )
        
        case 2: return .unverified(credentialInfo: try FfiConverterOptionTypeCredentialInfo.read(from: &buf), failure: try FfiConverterTypeFailure.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Outcome, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .verified(credentialInfo):
            writeInt(&buf, Int32(1))
            FfiConverterTypeCredentialInfo.write(credentialInfo, into: &buf)
            
        
        case let .unverified(credentialInfo,failure):
            writeInt(&buf, Int32(2))
            FfiConverterOptionTypeCredentialInfo.write(credentialInfo, into: &buf)
            FfiConverterTypeFailure.write(failure, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutcome_lift(_ buf: RustBuffer) throws -> Outcome {
    return try FfiConverterTypeOutcome.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOutcome_lower(_ value: Outcome) -> RustBuffer {
    return FfiConverterTypeOutcome.lower(value)
}


extension Outcome: Equatable, Hashable {}




public enum PermissionRequestError: Swift.Error {

    
    
    /**
     * Permission denied for requested presentation.
     */
    case PermissionDenied
    /**
     * No credentials found matching the presentation definition.
     */
    case NoCredentialsFound
    /**
     * Credential not found for input descriptor id.
     */
    case CredentialNotFound(String
    )
    /**
     * Input descriptor not found for input descriptor id.
     */
    case InputDescriptorNotFound(String
    )
    /**
     * Invalid selected credential for requested field. Selected
     * credential does not match optional credentials.
     */
    case InvalidSelectedCredential(String,String
    )
    /**
     * Credential Presentation Error
     *
     * failed to present the credential.
     */
    case CredentialPresentation(String
    )
    case RwLock(String
    )
    case PresentationSigning(String
    )
    case CryptographicSuite(String
    )
    case VerificationMethod(String
    )
    case LimitDisclosure
    case Presentation(PresentationError
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePermissionRequestError: FfiConverterRustBuffer {
    typealias SwiftType = PermissionRequestError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PermissionRequestError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .PermissionDenied
        case 2: return .NoCredentialsFound
        case 3: return .CredentialNotFound(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .InputDescriptorNotFound(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .InvalidSelectedCredential(
            try FfiConverterString.read(from: &buf), 
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .CredentialPresentation(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .RwLock(
            try FfiConverterString.read(from: &buf)
            )
        case 8: return .PresentationSigning(
            try FfiConverterString.read(from: &buf)
            )
        case 9: return .CryptographicSuite(
            try FfiConverterString.read(from: &buf)
            )
        case 10: return .VerificationMethod(
            try FfiConverterString.read(from: &buf)
            )
        case 11: return .LimitDisclosure
        case 12: return .Presentation(
            try FfiConverterTypePresentationError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PermissionRequestError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .PermissionDenied:
            writeInt(&buf, Int32(1))
        
        
        case .NoCredentialsFound:
            writeInt(&buf, Int32(2))
        
        
        case let .CredentialNotFound(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InputDescriptorNotFound(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidSelectedCredential(v1,v2):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            FfiConverterString.write(v2, into: &buf)
            
        
        case let .CredentialPresentation(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .RwLock(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .PresentationSigning(v1):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CryptographicSuite(v1):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .VerificationMethod(v1):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .LimitDisclosure:
            writeInt(&buf, Int32(11))
        
        
        case let .Presentation(v1):
            writeInt(&buf, Int32(12))
            FfiConverterTypePresentationError.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePermissionRequestError_lift(_ buf: RustBuffer) throws -> PermissionRequestError {
    return try FfiConverterTypePermissionRequestError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePermissionRequestError_lower(_ value: PermissionRequestError) -> RustBuffer {
    return FfiConverterTypePermissionRequestError.lower(value)
}


extension PermissionRequestError: Equatable, Hashable {}



extension PermissionRequestError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum PopError: Swift.Error {

    
    
    case DidError(message: String)
    
    case UrlParseError(message: String)
    
    case DidUrlParseError(message: String)
    
    case SerializationError(message: String)
    
    case ConversionError(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePopError: FfiConverterRustBuffer {
    typealias SwiftType = PopError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PopError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DidError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .UrlParseError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .DidUrlParseError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .SerializationError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .ConversionError(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PopError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .DidError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .UrlParseError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .DidUrlParseError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .SerializationError(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .ConversionError(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePopError_lift(_ buf: RustBuffer) throws -> PopError {
    return try FfiConverterTypePopError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePopError_lower(_ value: PopError) -> RustBuffer {
    return FfiConverterTypePopError.lower(value)
}


extension PopError: Equatable, Hashable {}



extension PopError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum PresentationBuilderError: Swift.Error {

    
    
    case DidError(message: String)
    
    case UrlParseError(message: String)
    
    case DidUrlParseError(message: String)
    
    case SerializationError(message: String)
    
    case ConversionError(message: String)
    
    case IriBufError(message: String)
    
    case UriBufError(message: String)
    
    case Context(message: String)
    
    case SignatureError(message: String)
    
    case SigningSuitePickError(message: String)
    
    case UnsupportedCredentialFormat(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePresentationBuilderError: FfiConverterRustBuffer {
    typealias SwiftType = PresentationBuilderError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PresentationBuilderError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DidError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .UrlParseError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .DidUrlParseError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .SerializationError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .ConversionError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .IriBufError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .UriBufError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .Context(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .SignatureError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .SigningSuitePickError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .UnsupportedCredentialFormat(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PresentationBuilderError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .DidError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .UrlParseError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .DidUrlParseError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .SerializationError(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .ConversionError(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .IriBufError(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .UriBufError(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .Context(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .SignatureError(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .SigningSuitePickError(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .UnsupportedCredentialFormat(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePresentationBuilderError_lift(_ buf: RustBuffer) throws -> PresentationBuilderError {
    return try FfiConverterTypePresentationBuilderError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePresentationBuilderError_lower(_ value: PresentationBuilderError) -> RustBuffer {
    return FfiConverterTypePresentationBuilderError.lower(value)
}


extension PresentationBuilderError: Equatable, Hashable {}



extension PresentationBuilderError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum PresentationError: Swift.Error {

    
    
    case Signing(String
    )
    case CryptographicSuite(String
    )
    case VerificationMethod(String
    )
    case Context(String
    )
    case Jwk(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePresentationError: FfiConverterRustBuffer {
    typealias SwiftType = PresentationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PresentationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Signing(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .CryptographicSuite(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .VerificationMethod(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .Context(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .Jwk(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PresentationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Signing(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CryptographicSuite(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .VerificationMethod(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Context(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Jwk(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePresentationError_lift(_ buf: RustBuffer) throws -> PresentationError {
    return try FfiConverterTypePresentationError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePresentationError_lower(_ value: PresentationError) -> RustBuffer {
    return FfiConverterTypePresentationError.lower(value)
}


extension PresentationError: Equatable, Hashable {}



extension PresentationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum RequestError: Swift.Error {

    
    
    case Generic(value: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestError: FfiConverterRustBuffer {
    typealias SwiftType = RequestError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestError_lift(_ buf: RustBuffer) throws -> RequestError {
    return try FfiConverterTypeRequestError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestError_lower(_ value: RequestError) -> RustBuffer {
    return FfiConverterTypeRequestError.lower(value)
}


extension RequestError: Equatable, Hashable {}



extension RequestError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum ResponseError: Swift.Error {

    
    
    case MissingSignature
    case Generic(value: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResponseError: FfiConverterRustBuffer {
    typealias SwiftType = ResponseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResponseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingSignature
        case 2: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResponseError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .MissingSignature:
            writeInt(&buf, Int32(1))
        
        
        case let .Generic(value):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResponseError_lift(_ buf: RustBuffer) throws -> ResponseError {
    return try FfiConverterTypeResponseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResponseError_lower(_ value: ResponseError) -> RustBuffer {
    return FfiConverterTypeResponseError.lower(value)
}


extension ResponseError: Equatable, Hashable {}



extension ResponseError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum SdJwtError: Swift.Error {

    
    
    case SdJwtVcInitError(String
    )
    case SdJwtDecoding(String
    )
    case InvalidSdJwt(String
    )
    case Serialization(String
    )
    case CredentialEncoding(String
    )
    case CredentialClaimMissing
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSdJwtError: FfiConverterRustBuffer {
    typealias SwiftType = SdJwtError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SdJwtError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SdJwtVcInitError(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .SdJwtDecoding(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidSdJwt(
            try FfiConverterString.read(from: &buf)
            )
        case 4: return .Serialization(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .CredentialEncoding(
            try FfiConverterString.read(from: &buf)
            )
        case 6: return .CredentialClaimMissing

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SdJwtError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SdJwtVcInitError(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .SdJwtDecoding(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidSdJwt(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Serialization(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .CredentialEncoding(v1):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .CredentialClaimMissing:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdJwtError_lift(_ buf: RustBuffer) throws -> SdJwtError {
    return try FfiConverterTypeSdJwtError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSdJwtError_lower(_ value: SdJwtError) -> RustBuffer {
    return FfiConverterTypeSdJwtError.lower(value)
}


extension SdJwtError: Equatable, Hashable {}



extension SdJwtError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum SessionError: Swift.Error {

    
    
    case Generic(value: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionError: FfiConverterRustBuffer {
    typealias SwiftType = SessionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SessionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionError_lift(_ buf: RustBuffer) throws -> SessionError {
    return try FfiConverterTypeSessionError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionError_lower(_ value: SessionError) -> RustBuffer {
    return FfiConverterTypeSessionError.lower(value)
}


extension SessionError: Equatable, Hashable {}



extension SessionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum SignatureError: Swift.Error {

    
    
    case InvalidSignature(value: String
    )
    case TooManyDocuments
    case Generic(value: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSignatureError: FfiConverterRustBuffer {
    typealias SwiftType = SignatureError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SignatureError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidSignature(
            value: try FfiConverterString.read(from: &buf)
            )
        case 2: return .TooManyDocuments
        case 3: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SignatureError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidSignature(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case .TooManyDocuments:
            writeInt(&buf, Int32(2))
        
        
        case let .Generic(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignatureError_lift(_ buf: RustBuffer) throws -> SignatureError {
    return try FfiConverterTypeSignatureError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSignatureError_lower(_ value: SignatureError) -> RustBuffer {
    return FfiConverterTypeSignatureError.lower(value)
}


extension SignatureError: Equatable, Hashable {}



extension SignatureError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum StatusListError: Swift.Error {

    
    
    case Resolution(String
    )
    case UnsupportedCredentialFormat
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStatusListError: FfiConverterRustBuffer {
    typealias SwiftType = StatusListError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StatusListError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Resolution(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .UnsupportedCredentialFormat

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StatusListError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Resolution(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .UnsupportedCredentialFormat:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStatusListError_lift(_ buf: RustBuffer) throws -> StatusListError {
    return try FfiConverterTypeStatusListError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStatusListError_lower(_ value: StatusListError) -> RustBuffer {
    return FfiConverterTypeStatusListError.lower(value)
}


extension StatusListError: Equatable, Hashable {}



extension StatusListError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



/**
 * Enum: StorageManagerError
 *
 * Represents errors that may occur during storage management operations
 */
public enum StorageManagerError: Swift.Error {

    
    
    /**
     * This error happens when the key value could not be used with the underlying
     * storage system on the device
     */
    case InvalidLookupKey
    /**
     * This error occurrs when we can retrieve a value, but could not decrypt it
     */
    case CouldNotDecryptValue
    /**
     * The underlying device has no more storage available
     */
    case StorageFull
    /**
     * During storage manager initialization, it must create a new encryption key.  This
     * error is raised when that key could not be created.
     */
    case CouldNotMakeKey
    /**
     * An internal problem occurred in the storage manager.
     */
    case InternalError
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStorageManagerError: FfiConverterRustBuffer {
    typealias SwiftType = StorageManagerError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StorageManagerError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidLookupKey
        case 2: return .CouldNotDecryptValue
        case 3: return .StorageFull
        case 4: return .CouldNotMakeKey
        case 5: return .InternalError

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StorageManagerError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidLookupKey:
            writeInt(&buf, Int32(1))
        
        
        case .CouldNotDecryptValue:
            writeInt(&buf, Int32(2))
        
        
        case .StorageFull:
            writeInt(&buf, Int32(3))
        
        
        case .CouldNotMakeKey:
            writeInt(&buf, Int32(4))
        
        
        case .InternalError:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageManagerError_lift(_ buf: RustBuffer) throws -> StorageManagerError {
    return try FfiConverterTypeStorageManagerError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStorageManagerError_lower(_ value: StorageManagerError) -> RustBuffer {
    return FfiConverterTypeStorageManagerError.lower(value)
}


extension StorageManagerError: Equatable, Hashable {}



extension StorageManagerError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum TerminationError: Swift.Error {

    
    
    case Generic(value: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTerminationError: FfiConverterRustBuffer {
    typealias SwiftType = TerminationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TerminationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TerminationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTerminationError_lift(_ buf: RustBuffer) throws -> TerminationError {
    return try FfiConverterTypeTerminationError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTerminationError_lower(_ value: TerminationError) -> RustBuffer {
    return FfiConverterTypeTerminationError.lower(value)
}


extension TerminationError: Equatable, Hashable {}



extension TerminationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum VcbVerificationError: Swift.Error {

    
    
    case Generic(value: String
    )
    case Verification
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVCBVerificationError: FfiConverterRustBuffer {
    typealias SwiftType = VcbVerificationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VcbVerificationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Verification

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VcbVerificationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case .Verification:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVCBVerificationError_lift(_ buf: RustBuffer) throws -> VcbVerificationError {
    return try FfiConverterTypeVCBVerificationError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVCBVerificationError_lower(_ value: VcbVerificationError) -> RustBuffer {
    return FfiConverterTypeVCBVerificationError.lower(value)
}


extension VcbVerificationError: Equatable, Hashable {}



extension VcbVerificationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum VcVerificationError: Swift.Error {

    
    
    case Generic(value: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVCVerificationError: FfiConverterRustBuffer {
    typealias SwiftType = VcVerificationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VcVerificationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VcVerificationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVCVerificationError_lift(_ buf: RustBuffer) throws -> VcVerificationError {
    return try FfiConverterTypeVCVerificationError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVCVerificationError_lower(_ value: VcVerificationError) -> RustBuffer {
    return FfiConverterTypeVCVerificationError.lower(value)
}


extension VcVerificationError: Equatable, Hashable {}



extension VcVerificationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum VpError: Swift.Error {

    
    
    case Verification
    case Signing
    case Parsing(value: String
    )
    case Generic(value: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVPError: FfiConverterRustBuffer {
    typealias SwiftType = VpError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VpError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Verification
        case 2: return .Signing
        case 3: return .Parsing(
            value: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Generic(
            value: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VpError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .Verification:
            writeInt(&buf, Int32(1))
        
        
        case .Signing:
            writeInt(&buf, Int32(2))
        
        
        case let .Parsing(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .Generic(value):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVPError_lift(_ buf: RustBuffer) throws -> VpError {
    return try FfiConverterTypeVPError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVPError_lower(_ value: VpError) -> RustBuffer {
    return FfiConverterTypeVPError.lower(value)
}


extension VpError: Equatable, Hashable {}



extension VpError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VcdmVersion {
    
    case v1
    case v2
}


#if compiler(>=6)
extension VcdmVersion: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVcdmVersion: FfiConverterRustBuffer {
    typealias SwiftType = VcdmVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VcdmVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v1
        
        case 2: return .v2
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VcdmVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .v1:
            writeInt(&buf, Int32(1))
        
        
        case .v2:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVcdmVersion_lift(_ buf: RustBuffer) throws -> VcdmVersion {
    return try FfiConverterTypeVcdmVersion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVcdmVersion_lower(_ value: VcdmVersion) -> RustBuffer {
    return FfiConverterTypeVcdmVersion.lower(value)
}


extension VcdmVersion: Equatable, Hashable {}




public enum VdcCollectionError: Swift.Error {

    
    
    /**
     * Attempt to convert the credential to a serialized form suitable for writing to storage failed.
     */
    case SerializeFailed
    /**
     * Attempting to convert the credential to a deserialized form suitable for runtime use failed.
     */
    case DeserializeFailed
    /**
     * Attempting to write the credential to storage failed.
     */
    case StoreFailed(StorageManagerError
    )
    /**
     * Attempting to read the credential from storage failed.
     */
    case LoadFailed(StorageManagerError
    )
    /**
     * Attempting to delete a credential from storage failed.
     */
    case DeleteFailed(StorageManagerError
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVdcCollectionError: FfiConverterRustBuffer {
    typealias SwiftType = VdcCollectionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VdcCollectionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SerializeFailed
        case 2: return .DeserializeFailed
        case 3: return .StoreFailed(
            try FfiConverterTypeStorageManagerError.read(from: &buf)
            )
        case 4: return .LoadFailed(
            try FfiConverterTypeStorageManagerError.read(from: &buf)
            )
        case 5: return .DeleteFailed(
            try FfiConverterTypeStorageManagerError.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VdcCollectionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .SerializeFailed:
            writeInt(&buf, Int32(1))
        
        
        case .DeserializeFailed:
            writeInt(&buf, Int32(2))
        
        
        case let .StoreFailed(v1):
            writeInt(&buf, Int32(3))
            FfiConverterTypeStorageManagerError.write(v1, into: &buf)
            
        
        case let .LoadFailed(v1):
            writeInt(&buf, Int32(4))
            FfiConverterTypeStorageManagerError.write(v1, into: &buf)
            
        
        case let .DeleteFailed(v1):
            writeInt(&buf, Int32(5))
            FfiConverterTypeStorageManagerError.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVdcCollectionError_lift(_ buf: RustBuffer) throws -> VdcCollectionError {
    return try FfiConverterTypeVdcCollectionError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVdcCollectionError_lower(_ value: VdcCollectionError) -> RustBuffer {
    return FfiConverterTypeVdcCollectionError.lower(value)
}


extension VdcCollectionError: Equatable, Hashable {}



extension VdcCollectionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VerificationResult {
    
    case success
    case failure(cause: String
    )
}


#if compiler(>=6)
extension VerificationResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVerificationResult: FfiConverterRustBuffer {
    typealias SwiftType = VerificationResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerificationResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .success
        
        case 2: return .failure(cause: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerificationResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case .success:
            writeInt(&buf, Int32(1))
        
        
        case let .failure(cause):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(cause, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerificationResult_lift(_ buf: RustBuffer) throws -> VerificationResult {
    return try FfiConverterTypeVerificationResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerificationResult_lower(_ value: VerificationResult) -> RustBuffer {
    return FfiConverterTypeVerificationResult.lower(value)
}


extension VerificationResult: Equatable, Hashable {}




public enum WalletServiceError: Swift.Error {

    
    
    /**
     * Failed to parse the JWK as valid JSON
     */
    case InvalidJson(String
    )
    /**
     * Failed to send the login request
     */
    case NetworkError(String
    )
    /**
     * Server returned an error response
     */
    case ServerError(status: UInt16, errorMessage: String
    )
    /**
     * Failed to read the response body
     */
    case ResponseError(String
    )
    /**
     * Token is expired or invalid
     */
    case InvalidToken
    /**
     * Failed to parse JWT claims
     */
    case JwtParseError(String
    )
    /**
     * Internal error
     */
    case InternalError(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWalletServiceError: FfiConverterRustBuffer {
    typealias SwiftType = WalletServiceError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletServiceError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidJson(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .NetworkError(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .ServerError(
            status: try FfiConverterUInt16.read(from: &buf), 
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 4: return .ResponseError(
            try FfiConverterString.read(from: &buf)
            )
        case 5: return .InvalidToken
        case 6: return .JwtParseError(
            try FfiConverterString.read(from: &buf)
            )
        case 7: return .InternalError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WalletServiceError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidJson(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .NetworkError(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .ServerError(status,errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterUInt16.write(status, into: &buf)
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .ResponseError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .InvalidToken:
            writeInt(&buf, Int32(5))
        
        
        case let .JwtParseError(v1):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InternalError(v1):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletServiceError_lift(_ buf: RustBuffer) throws -> WalletServiceError {
    return try FfiConverterTypeWalletServiceError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWalletServiceError_lower(_ value: WalletServiceError) -> RustBuffer {
    return FfiConverterTypeWalletServiceError.lower(value)
}


extension WalletServiceError: Equatable, Hashable {}



extension WalletServiceError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





/**
 * The `PresentationSigner` foreign callback interface to be implemented
 * by the host environment, e.g. Kotlin or Swift.
 *
 * Signing is handled after the authorization request is reviewed and authorized
 * and the credentials for presentation have been selected.
 *
 * The payload for signing is determined by the credential format and the encoding
 * type of the `vp_token`.
 *
 * For example, in the case of `JwtVc` credential format,
 * the signing payload consists of the JWT header and payload (JWS).
 */
public protocol PresentationSigner: AnyObject, Sendable {
    
    /**
     * Sign the payload with the private key and return the signature.
     *
     * The signing algorithm must match the `cryptosuite()` method result.
     */
    func sign(payload: Data) async throws  -> Data
    
    /**
     * Return the algorithm used for signing the vp token.
     *
     * E.g., "ES256"
     */
    func algorithm()  -> Algorithm
    
    /**
     * Return the verification method associated with the signing key.
     */
    func verificationMethod() async  -> String
    
    /**
     * Return the `DID` of the signing key.
     */
    func did()  -> String
    
    /**
     * Data Integrity Cryptographic Suite of the Signer.
     *
     * This corresponds to the `proof_type` in the
     * authorization request corresponding to the
     * format of the verifiable presentation, e.g,
     * `ldp_vp`, `jwt_vp`.
     *
     *
     * E.g., JsonWebSignature2020, ecdsa-rdfc-2019
     */
    func cryptosuite()  -> CryptosuiteString
    
    /**
     * Return the public JWK of the signing key.
     * as a String-encoded JSON
     */
    func jwk()  -> String
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfacePresentationSigner {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfacePresentationSigner] = [UniffiVTableCallbackInterfacePresentationSigner(
        sign: { (
            uniffiHandle: UInt64,
            payload: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Data in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.sign(
                     payload: try FfiConverterData.lift(payload)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Data) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterData.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypePresentationError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        algorithm: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Algorithm in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.algorithm(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeAlgorithm_lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        verificationMethod: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> String in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return await uniffiObj.verificationMethod(
                )
            }

            let uniffiHandleSuccess = { (returnValue: String) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterString.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsync(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        did: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> String in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.did(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        cryptosuite: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> CryptosuiteString in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.cryptosuite(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeCryptosuiteString_lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        jwk: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> String in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.jwk(
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterString.lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfacePresentationSigner.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface PresentationSigner: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitPresentationSigner() {
    uniffi_mobile_sdk_rs_fn_init_callback_vtable_presentationsigner(UniffiCallbackInterfacePresentationSigner.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfacePresentationSigner {
    fileprivate static let handleMap = UniffiHandleMap<PresentationSigner>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfacePresentationSigner : FfiConverter {
    typealias SwiftType = PresentationSigner
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfacePresentationSigner_lift(_ handle: UInt64) throws -> PresentationSigner {
    return try FfiConverterCallbackInterfacePresentationSigner.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfacePresentationSigner_lower(_ v: PresentationSigner) -> UInt64 {
    return FfiConverterCallbackInterfacePresentationSigner.lower(v)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeCwt: FfiConverterRustBuffer {
    typealias SwiftType = Cwt?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCwt.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCwt.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeJsonVc: FfiConverterRustBuffer {
    typealias SwiftType = JsonVc?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeJsonVc.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeJsonVc.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeJwtVc: FfiConverterRustBuffer {
    typealias SwiftType = JwtVc?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeJwtVc.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeJwtVc.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMdoc: FfiConverterRustBuffer {
    typealias SwiftType = Mdoc?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMdoc.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMdoc.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeVCDM2SdJwt: FfiConverterRustBuffer {
    typealias SwiftType = Vcdm2SdJwt?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVCDM2SdJwt.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVCDM2SdJwt.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeCredential: FfiConverterRustBuffer {
    typealias SwiftType = Credential?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCredential.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCredential.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeCredentialInfo: FfiConverterRustBuffer {
    typealias SwiftType = CredentialInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCredentialInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCredentialInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeDelegatedVerifierOid4vpResponse: FfiConverterRustBuffer {
    typealias SwiftType = DelegatedVerifierOid4vpResponse?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDelegatedVerifierOid4vpResponse.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDelegatedVerifierOid4vpResponse.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDictionaryStringString: FfiConverterRustBuffer {
    typealias SwiftType = [String: String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeKeyAlias: FfiConverterRustBuffer {
    typealias SwiftType = KeyAlias?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeKeyAlias.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeKeyAlias.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUrl: FfiConverterRustBuffer {
    typealias SwiftType = Url?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUrl.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUrl.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeValue: FfiConverterRustBuffer {
    typealias SwiftType = Value?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeValue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeValue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMdoc: FfiConverterRustBuffer {
    typealias SwiftType = [Mdoc]

    public static func write(_ value: [Mdoc], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMdoc.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Mdoc] {
        let len: Int32 = try readInt(&buf)
        var seq = [Mdoc]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMdoc.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeParsedCredential: FfiConverterRustBuffer {
    typealias SwiftType = [ParsedCredential]

    public static func write(_ value: [ParsedCredential], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeParsedCredential.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ParsedCredential] {
        let len: Int32 = try readInt(&buf)
        var seq = [ParsedCredential]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeParsedCredential.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePresentableCredential: FfiConverterRustBuffer {
    typealias SwiftType = [PresentableCredential]

    public static func write(_ value: [PresentableCredential], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePresentableCredential.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PresentableCredential] {
        let len: Int32 = try readInt(&buf)
        var seq = [PresentableCredential]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePresentableCredential.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRequestMatch180137: FfiConverterRustBuffer {
    typealias SwiftType = [RequestMatch180137]

    public static func write(_ value: [RequestMatch180137], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRequestMatch180137.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RequestMatch180137] {
        let len: Int32 = try readInt(&buf)
        var seq = [RequestMatch180137]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequestMatch180137.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRequestedField: FfiConverterRustBuffer {
    typealias SwiftType = [RequestedField]

    public static func write(_ value: [RequestedField], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRequestedField.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RequestedField] {
        let len: Int32 = try readInt(&buf)
        var seq = [RequestedField]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequestedField.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeStatus20240406: FfiConverterRustBuffer {
    typealias SwiftType = [Status20240406]

    public static func write(_ value: [Status20240406], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeStatus20240406.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Status20240406] {
        let len: Int32 = try readInt(&buf)
        var seq = [Status20240406]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeStatus20240406.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCredentialResponse: FfiConverterRustBuffer {
    typealias SwiftType = [CredentialResponse]

    public static func write(_ value: [CredentialResponse], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCredentialResponse.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CredentialResponse] {
        let len: Int32 = try readInt(&buf)
        var seq = [CredentialResponse]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCredentialResponse.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeElement: FfiConverterRustBuffer {
    typealias SwiftType = [Element]

    public static func write(_ value: [Element], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeElement.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Element] {
        let len: Int32 = try readInt(&buf)
        var seq = [Element]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeElement.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeItemsRequest: FfiConverterRustBuffer {
    typealias SwiftType = [ItemsRequest]

    public static func write(_ value: [ItemsRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeItemsRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ItemsRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [ItemsRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeItemsRequest.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRequestedField180137: FfiConverterRustBuffer {
    typealias SwiftType = [RequestedField180137]

    public static func write(_ value: [RequestedField180137], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRequestedField180137.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RequestedField180137] {
        let len: Int32 = try readInt(&buf)
        var seq = [RequestedField180137]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRequestedField180137.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeStatusMessage: FfiConverterRustBuffer {
    typealias SwiftType = [StatusMessage]

    public static func write(_ value: [StatusMessage], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeStatusMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [StatusMessage] {
        let len: Int32 = try readInt(&buf)
        var seq = [StatusMessage]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeStatusMessage.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCborValue: FfiConverterRustBuffer {
    typealias SwiftType = [CborValue]

    public static func write(_ value: [CborValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCborValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [CborValue] {
        let len: Int32 = try readInt(&buf)
        var seq = [CborValue]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCborValue.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMDocItem: FfiConverterRustBuffer {
    typealias SwiftType = [MDocItem]

    public static func write(_ value: [MDocItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMDocItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MDocItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [MDocItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMDocItem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]

    public static func write(_ value: [[String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[String]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[String]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFieldId180137: FfiConverterRustBuffer {
    typealias SwiftType = [FieldId180137]

    public static func write(_ value: [FieldId180137], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFieldId180137.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FieldId180137] {
        let len: Int32 = try readInt(&buf)
        var seq = [FieldId180137]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFieldId180137.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeKey: FfiConverterRustBuffer {
    typealias SwiftType = [Key]

    public static func write(_ value: [Key], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Key] {
        let len: Int32 = try readInt(&buf)
        var seq = [Key]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeKey.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUuid: FfiConverterRustBuffer {
    typealias SwiftType = [Uuid]

    public static func write(_ value: [Uuid], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUuid.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Uuid] {
        let len: Int32 = try readInt(&buf)
        var seq = [Uuid]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUuid.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringBool: FfiConverterRustBuffer {
    public static func write(_ value: [String: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeCborValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: CborValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeCborValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: CborValue] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: CborValue]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeCborValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeClaimValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: ClaimValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeClaimValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: ClaimValue] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: ClaimValue]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeClaimValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeMDocItem: FfiConverterRustBuffer {
    public static func write(_ value: [String: MDocItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeMDocItem.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: MDocItem] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: MDocItem]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeMDocItem.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringDictionaryStringBool: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: Bool]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: Bool]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: Bool]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringDictionaryStringTypeMDocItem: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: MDocItem]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringTypeMDocItem.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: MDocItem]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: MDocItem]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringTypeMDocItem.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String: [String]]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterDictionaryStringSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String: [String]]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String: [String]]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterDictionaryStringSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeNamespaceSequenceTypeElement: FfiConverterRustBuffer {
    public static func write(_ value: [Namespace: [Element]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeNamespace.write(key, into: &buf)
            FfiConverterSequenceTypeElement.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Namespace: [Element]] {
        let len: Int32 = try readInt(&buf)
        var dict = [Namespace: [Element]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeNamespace.read(from: &buf)
            let value = try FfiConverterSequenceTypeElement.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Algorithm = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAlgorithm: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Algorithm {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Algorithm, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Algorithm {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Algorithm) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAlgorithm_lift(_ value: RustBuffer) throws -> Algorithm {
    return try FfiConverterTypeAlgorithm.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAlgorithm_lower(_ value: Algorithm) -> RustBuffer {
    return FfiConverterTypeAlgorithm.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias AuthRequest = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthRequest: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthRequest {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: AuthRequest, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> AuthRequest {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: AuthRequest) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthRequest_lift(_ value: RustBuffer) throws -> AuthRequest {
    return try FfiConverterTypeAuthRequest.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthRequest_lower(_ value: AuthRequest) -> RustBuffer {
    return FfiConverterTypeAuthRequest.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BitString20240406StatusPurpose = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitString20240406StatusPurpose: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitString20240406StatusPurpose {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: BitString20240406StatusPurpose, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BitString20240406StatusPurpose {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: BitString20240406StatusPurpose) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitString20240406StatusPurpose_lift(_ value: RustBuffer) throws -> BitString20240406StatusPurpose {
    return try FfiConverterTypeBitString20240406StatusPurpose.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitString20240406StatusPurpose_lower(_ value: BitString20240406StatusPurpose) -> RustBuffer {
    return FfiConverterTypeBitString20240406StatusPurpose.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias BitStringStatusPurpose = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBitStringStatusPurpose: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitStringStatusPurpose {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: BitStringStatusPurpose, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> BitStringStatusPurpose {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: BitStringStatusPurpose) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitStringStatusPurpose_lift(_ value: RustBuffer) throws -> BitStringStatusPurpose {
    return try FfiConverterTypeBitStringStatusPurpose.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBitStringStatusPurpose_lower(_ value: BitStringStatusPurpose) -> RustBuffer {
    return FfiConverterTypeBitStringStatusPurpose.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias CredentialType = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCredentialType: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CredentialType {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: CredentialType, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> CredentialType {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: CredentialType) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialType_lift(_ value: RustBuffer) throws -> CredentialType {
    return try FfiConverterTypeCredentialType.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCredentialType_lower(_ value: CredentialType) -> RustBuffer {
    return FfiConverterTypeCredentialType.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias CryptosuiteString = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCryptosuiteString: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CryptosuiteString {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: CryptosuiteString, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> CryptosuiteString {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: CryptosuiteString) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCryptosuiteString_lift(_ value: RustBuffer) throws -> CryptosuiteString {
    return try FfiConverterTypeCryptosuiteString.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCryptosuiteString_lower(_ value: CryptosuiteString) -> RustBuffer {
    return FfiConverterTypeCryptosuiteString.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias FieldId180137 = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFieldId180137: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FieldId180137 {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: FieldId180137, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> FieldId180137 {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: FieldId180137) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFieldId180137_lift(_ value: RustBuffer) throws -> FieldId180137 {
    return try FfiConverterTypeFieldId180137.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFieldId180137_lower(_ value: FieldId180137) -> RustBuffer {
    return FfiConverterTypeFieldId180137.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Key = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKey: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Key {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Key, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Key {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Key) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKey_lift(_ value: RustBuffer) throws -> Key {
    return try FfiConverterTypeKey.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKey_lower(_ value: Key) -> RustBuffer {
    return FfiConverterTypeKey.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias KeyAlias = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyAlias: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyAlias {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: KeyAlias, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> KeyAlias {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: KeyAlias) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyAlias_lift(_ value: RustBuffer) throws -> KeyAlias {
    return try FfiConverterTypeKeyAlias.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyAlias_lower(_ value: KeyAlias) -> RustBuffer {
    return FfiConverterTypeKeyAlias.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Namespace = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNamespace: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Namespace {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Namespace, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Namespace {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Namespace) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNamespace_lift(_ value: RustBuffer) throws -> Namespace {
    return try FfiConverterTypeNamespace.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNamespace_lower(_ value: Namespace) -> RustBuffer {
    return FfiConverterTypeNamespace.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Url = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUrl: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Url {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Url, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Url {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Url) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrl_lift(_ value: RustBuffer) throws -> Url {
    return try FfiConverterTypeUrl.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUrl_lower(_ value: Url) -> RustBuffer {
    return FfiConverterTypeUrl.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Uuid = String

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUuid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Uuid {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Uuid, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Uuid {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Uuid) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUuid_lift(_ value: RustBuffer) throws -> Uuid {
    return try FfiConverterTypeUuid.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUuid_lower(_ value: Uuid) -> RustBuffer {
    return FfiConverterTypeUuid.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Value = Data

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeValue: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Value {
        return try FfiConverterData.read(from: &buf)
    }

    public static func write(_ value: Value, into buf: inout [UInt8]) {
        return FfiConverterData.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Value {
        return try FfiConverterData.lift(value)
    }

    public static func lower(_ value: Value) -> RustBuffer {
        return FfiConverterData.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValue_lift(_ value: RustBuffer) throws -> Value {
    return try FfiConverterTypeValue.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeValue_lower(_ value: Value) -> RustBuffer {
    return FfiConverterTypeValue.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureMobileSdkRsInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate let UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
fileprivate protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountMobileSdkRs() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
public func cborLdEncodeToBytes(credentialStr: String, loader: [String: String]?)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_cbor_ld_encode_to_bytes(FfiConverterString.lower(credentialStr),FfiConverterOptionDictionaryStringString.lower(loader)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeCborLdEncodingError_lift
        )
}
/**
 * Configure the global logger for the mobile SDK.
 *
 * This method should be called once per application lifecycle. Subsequent calls will be ignored.
 */
public func configureLogger(writer: LogWriter)  {try! rustCall() {
    uniffi_mobile_sdk_rs_fn_func_configure_logger(
        FfiConverterTypeLogWriter_lower(writer),$0
    )
}
}
public func decodeRevealSdJwt(input: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeSdJwtError_lift) {
    uniffi_mobile_sdk_rs_fn_func_decode_reveal_sd_jwt(
        FfiConverterString.lower(input),$0
    )
})
}
/**
 * Return the default context for the mobile SDK
 *
 * Includes VC playground contexts
 */
public func defaultLdJsonContext() -> [String: String]  {
    return try!  FfiConverterDictionaryStringString.lift(try! rustCall() {
    uniffi_mobile_sdk_rs_fn_func_default_ld_json_context($0
    )
})
}
public func establishSession(uri: String, requestedItems: [String: [String: Bool]], trustAnchorRegistry: [String]?)throws  -> MdlReaderSessionData  {
    return try  FfiConverterTypeMDLReaderSessionData_lift(try rustCallWithError(FfiConverterTypeMDLReaderSessionError_lift) {
    uniffi_mobile_sdk_rs_fn_func_establish_session(
        FfiConverterString.lower(uri),
        FfiConverterDictionaryStringDictionaryStringBool.lower(requestedItems),
        FfiConverterOptionSequenceString.lower(trustAnchorRegistry),$0
    )
})
}
public func generatePopComplete(signingInput: Data, signatureDer: Data)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeOid4vciError_lift) {
    uniffi_mobile_sdk_rs_fn_func_generate_pop_complete(
        FfiConverterData.lower(signingInput),
        FfiConverterData.lower(signatureDer),$0
    )
})
}
public func generatePopPrepare(audience: String, nonce: String?, didMethod: DidMethod, publicJwk: String, durationInSecs: Int64?)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_generate_pop_prepare(FfiConverterString.lower(audience),FfiConverterOptionString.lower(nonce),FfiConverterTypeDidMethod_lower(didMethod),FfiConverterString.lower(publicJwk),FfiConverterOptionInt64.lower(durationInSecs)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypePopError_lift
        )
}
/**
 * Generate a new test mDL with hardcoded values, using the supplied key as the DeviceKey.
 */
public func generateTestMdl(keyManager: KeyStore, keyAlias: KeyAlias)throws  -> Mdoc  {
    return try  FfiConverterTypeMdoc_lift(try rustCallWithError(FfiConverterTypeMdlUtilError_lift) {
    uniffi_mobile_sdk_rs_fn_func_generate_test_mdl(
        FfiConverterTypeKeyStore_lower(keyManager),
        FfiConverterTypeKeyAlias_lower(keyAlias),$0
    )
})
}
/**
 * Handle a DC API request.
 *
 * Supports OpenID4VP Draft 24 using DCQL for mDL only.
 */
public func handleDcApiRequest(dcqlCredentialId: String, mdoc: Mdoc, origin: String, requestJson: String)async throws  -> InProgressRequestDcApi  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_handle_dc_api_request(FfiConverterString.lower(dcqlCredentialId),FfiConverterTypeMdoc_lower(mdoc),FfiConverterString.lower(origin),FfiConverterString.lower(requestJson)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeInProgressRequestDcApi_lift,
            errorHandler: FfiConverterTypeDcApiError_lift
        )
}
public func handleResponse(state: MdlSessionManager, response: Data)throws  -> MdlReaderResponseData  {
    return try  FfiConverterTypeMDLReaderResponseData_lift(try rustCallWithError(FfiConverterTypeMDLReaderResponseError_lift) {
    uniffi_mobile_sdk_rs_fn_func_handle_response(
        FfiConverterTypeMDLSessionManager_lower(state),
        FfiConverterData.lower(response),$0
    )
})
}
/**
 * Begin the mDL presentation process for the holder when the desired
 * Mdoc is already stored in a [VdcCollection].
 *
 * Initializes the presentation session for an ISO 18013-5 mDL and stores
 * the session state object in the device storage_manager.
 *
 * Arguments:
 * mdoc_id: unique identifier for the credential to present, to be looked up
 * in the VDC collection
 * uuid:    the Bluetooth Low Energy Client Central Mode UUID to be used
 *
 * Returns:
 * A Result, with the `Ok` containing a tuple consisting of an enum representing
 * the state of the presentation, a String containing the QR code URI, and a
 * String containing the BLE ident.

 */
public func initializeMdlPresentation(mdocId: Uuid, uuid: Uuid, storageManager: StorageManagerInterface)async throws  -> MdlPresentationSession  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_initialize_mdl_presentation(FfiConverterTypeUuid_lower(mdocId),FfiConverterTypeUuid_lower(uuid),FfiConverterTypeStorageManagerInterface_lower(storageManager)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeMdlPresentationSession_lift,
            errorHandler: FfiConverterTypeSessionError_lift
        )
}
/**
 * Begin the mDL presentation process for the holder by passing in the credential
 * to be presented in the form of an [Mdoc] object.
 *
 * Initializes the presentation session for an ISO 18013-5 mDL and stores
 * the session state object in the device storage_manager.
 *
 * Arguments:
 * mdoc: the Mdoc to be presented, as an [Mdoc] object
 * uuid: the Bluetooth Low Energy Client Central Mode UUID to be used
 *
 * Returns:
 * A Result, with the `Ok` containing a tuple consisting of an enum representing
 * the state of the presentation, a String containing the QR code URI, and a
 * String containing the BLE ident.

 */
public func initializeMdlPresentationFromBytes(mdoc: Mdoc, uuid: Uuid)throws  -> MdlPresentationSession  {
    return try  FfiConverterTypeMdlPresentationSession_lift(try rustCallWithError(FfiConverterTypeSessionError_lift) {
    uniffi_mobile_sdk_rs_fn_func_initialize_mdl_presentation_from_bytes(
        FfiConverterTypeMdoc_lower(mdoc),
        FfiConverterTypeUuid_lower(uuid),$0
    )
})
}
public func listSdFields(input: Vcdm2SdJwt)throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeSdJwtError_lift) {
    uniffi_mobile_sdk_rs_fn_func_list_sd_fields(
        FfiConverterTypeVCDM2SdJwt_lower(input),$0
    )
})
}
public func logSomething(message: String)  {try! rustCall() {
    uniffi_mobile_sdk_rs_fn_func_log_something(
        FfiConverterString.lower(message),$0
    )
}
}
public func oid4vciExchangeCredential(session: Oid4vciSession, proofsOfPossession: [String], options: Oid4vciExchangeOptions, contextMap: [String: String]?, httpClient: IHttpClient)async throws  -> [CredentialResponse]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_oid4vci_exchange_credential(FfiConverterTypeOid4vciSession_lower(session),FfiConverterSequenceString.lower(proofsOfPossession),FfiConverterTypeOid4vciExchangeOptions_lower(options),FfiConverterOptionDictionaryStringString.lower(contextMap),FfiConverterTypeIHttpClient_lower(httpClient)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeCredentialResponse.lift,
            errorHandler: FfiConverterTypeOid4vciError_lift
        )
}
public func oid4vciExchangeToken(session: Oid4vciSession, httpClient: IHttpClient)async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_oid4vci_exchange_token(FfiConverterTypeOid4vciSession_lower(session),FfiConverterTypeIHttpClient_lower(httpClient)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeOid4vciError_lift
        )
}
public func oid4vciGetMetadata(session: Oid4vciSession)throws  -> Oid4vciMetadata  {
    return try  FfiConverterTypeOid4vciMetadata_lift(try rustCallWithError(FfiConverterTypeOid4vciError_lift) {
    uniffi_mobile_sdk_rs_fn_func_oid4vci_get_metadata(
        FfiConverterTypeOid4vciSession_lower(session),$0
    )
})
}
public func oid4vciInitiate(baseUrl: String, clientId: String, redirectUrl: String, httpClient: IHttpClient)async throws  -> Oid4vciSession  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_oid4vci_initiate(FfiConverterString.lower(baseUrl),FfiConverterString.lower(clientId),FfiConverterString.lower(redirectUrl),FfiConverterTypeIHttpClient_lower(httpClient)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeOid4vciSession_lift,
            errorHandler: FfiConverterTypeOid4vciError_lift
        )
}
public func oid4vciInitiateWithOffer(credentialOffer: String, clientId: String, redirectUrl: String, httpClient: IHttpClient)async throws  -> Oid4vciSession  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_oid4vci_initiate_with_offer(FfiConverterString.lower(credentialOffer),FfiConverterString.lower(clientId),FfiConverterString.lower(redirectUrl),FfiConverterTypeIHttpClient_lower(httpClient)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_pointer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_pointer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_pointer,
            liftFunc: FfiConverterTypeOid4vciSession_lift,
            errorHandler: FfiConverterTypeOid4vciError_lift
        )
}
public func vcToSignedVp(vc: String, keyStr: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_vc_to_signed_vp(FfiConverterString.lower(vc),FfiConverterString.lower(keyStr)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_rust_buffer,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_rust_buffer,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeVPError_lift
        )
}
public func verifiedResponseAsJsonString(response: MdlReaderResponseData)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeMDLReaderResponseSerializeError_lift) {
    uniffi_mobile_sdk_rs_fn_func_verified_response_as_json_string(
        FfiConverterTypeMDLReaderResponseData_lower(response),$0
    )
})
}
public func verifyJsonVcString(json: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_verify_json_vc_string(FfiConverterString.lower(json)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVCVerificationError_lift
        )
}
public func verifyJwtVp(jwtVp: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_verify_jwt_vp(FfiConverterString.lower(jwtVp)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVPError_lift
        )
}
public func verifyPdf417Barcode(payload: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_verify_pdf417_barcode(FfiConverterString.lower(payload)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVCBVerificationError_lift
        )
}
public func verifyVcbQrcodeAgainstMrz(mrzPayload: String, qrPayload: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_mobile_sdk_rs_fn_func_verify_vcb_qrcode_against_mrz(FfiConverterString.lower(mrzPayload),FfiConverterString.lower(qrPayload)
                )
            },
            pollFunc: ffi_mobile_sdk_rs_rust_future_poll_void,
            completeFunc: ffi_mobile_sdk_rs_rust_future_complete_void,
            freeFunc: ffi_mobile_sdk_rs_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeVCBVerificationError_lift
        )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_mobile_sdk_rs_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_cbor_ld_encode_to_bytes() != 12635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_configure_logger() != 58645) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_decode_reveal_sd_jwt() != 34951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_default_ld_json_context() != 13685) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_establish_session() != 26937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_generate_pop_complete() != 41207) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_generate_pop_prepare() != 54105) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_generate_test_mdl() != 22635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_handle_dc_api_request() != 11589) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_handle_response() != 43961) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_initialize_mdl_presentation() != 29387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_initialize_mdl_presentation_from_bytes() != 26972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_list_sd_fields() != 63228) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_log_something() != 42419) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_exchange_credential() != 25671) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_exchange_token() != 3394) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_get_metadata() != 16967) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_initiate() != 45435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_oid4vci_initiate_with_offer() != 12958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_vc_to_signed_vp() != 47312) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_verified_response_as_json_string() != 8701) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_verify_json_vc_string() != 13072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_verify_jwt_vp() != 8825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_verify_pdf417_barcode() != 14164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_func_verify_vcb_qrcode_against_mrz() != 36527) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_asynchttpclient_http_client() != 44924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_cborinteger_lower_bytes() != 43619) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_cborinteger_to_text() != 47096) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_cborinteger_upper_bytes() != 10015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_cbortag_id() != 65367) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_cbortag_value() != 9924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_crypto_p256_verify() != 31057) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_cryptocurveutils_ensure_raw_fixed_width_signature_encoding() != 55703) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_cwt_claims() != 13544) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_cwt_id() != 47275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_cwt_key_alias() != 20086) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_cwt_type() != 62248) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_cwt_verify() != 48612) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_delegatedverifier_poll_verification_status() != 35131) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_delegatedverifier_request_delegated_verification() != 37161) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_didmethodutils_did_from_jwk() != 55995) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_didmethodutils_vm_from_jwk() != 9065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_holder_authorization_request() != 37629) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_holder_submit_permission_response() != 37701) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_inprogressrequest180137_matches() != 21157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_inprogressrequest180137_respond() != 45984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_inprogressrequestdcapi_get_match() != 64333) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_inprogressrequestdcapi_get_origin() != 46706) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_inprogressrequestdcapi_respond() != 18977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_issuanceserviceclient_check_status() != 43341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_issuanceserviceclient_new_issuance() != 231) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonldpresentationbuilder_issue_presentation() != 17531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_credential_as_json_encoded_utf8_string() != 36585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_id() != 12139) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_key_alias() != 36306) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_status() != 56187) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_type() != 48063) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_types() != 3171) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jsonvc_vcdm_version() != 26490) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_credential_as_json_encoded_utf8_string() != 41803) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_id() != 55448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_jws_header_as_json_encoded_utf8_string() != 46211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_jws_payload_as_json_encoded_utf8_string() != 6252) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_key_alias() != 13659) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_type() != 41101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_types() != 60467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_jwtvc_vcdm_version() != 26158) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_keystore_get_signing_key() != 18910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_logwriter_write_to_buffer() != 179) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_logwriter_flush() != 63605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_generate_response() != 37013) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_get_ble_ident() != 25991) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_get_qr_code_uri() != 36281) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_handle_request() != 21650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_submit_response() != 53424) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdlpresentationsession_terminate_session() != 8677) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdoc_details() != 29355) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdoc_doctype() != 46465) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdoc_id() != 18877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_mdoc_key_alias() != 39341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vp180137_process_request() != 48065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_clear_context_map() != 165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_exchange_credential() != 53636) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_exchange_token() != 35585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_get_metadata() != 38460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_initiate() != 12704) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_initiate_with_offer() != 23294) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vci_set_context_map() != 64024) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_authorization_servers() != 42340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_batch_credential_endpoint() != 60237) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_credential_endpoint() != 16138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_deferred_credential_endpoint() != 24938) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_issuer() != 28727) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_notification_endpoint() != 39275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_oid4vcimetadata_to_json() != 52469) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_as_cwt() != 46037) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_as_json_vc() != 62122) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_as_jwt_vc() != 38850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_as_mso_mdoc() != 54804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_as_sd_jwt() != 23438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_format() != 39112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_id() != 46894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_into_generic_form() != 30318) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_key_alias() != 52023) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_parsedcredential_type() != 60750) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_permissionrequest_client_id() != 37346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_permissionrequest_create_permission_response() != 13542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_permissionrequest_credentials() != 19351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_permissionrequest_domain() != 60512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_permissionrequest_purpose() != 28780) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_permissionrequest_requested_fields() != 61931) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_permissionresponse_selected_credentials() != 2870) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_permissionresponse_vp_token() != 26646) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentablecredential_as_parsed_credential() != 56853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentablecredential_selective_disclosable() != 24142) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestmatch180137_credential_id() != 33906) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestmatch180137_requested_fields() != 52220) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestedfield_id() != 35305) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestedfield_input_descriptor_id() != 9742) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestedfield_name() != 19474) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestedfield_path() != 29964) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestedfield_purpose() != 46977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestedfield_raw_fields() != 44847) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestedfield_required() != 14409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_requestedfield_retained() != 21715) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_signingkey_jwk() != 16453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_signingkey_sign() != 37168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status_is_message() != 61380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status_is_revoked() != 37392) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status_is_suspended() != 54379) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status_messages() != 26217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status_purpose() != 52884) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status20240406_is_message() != 61330) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status20240406_is_revoked() != 51346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status20240406_is_suspended() != 4970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status20240406_messages() != 22990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_status20240406_purpose() != 44602) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_storagemanagerinterface_add() != 39162) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_storagemanagerinterface_get() != 35430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_storagemanagerinterface_list() != 37678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_storagemanagerinterface_remove() != 24982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_synchttpclient_http_client() != 53085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vcdm2sdjwt_id() != 13770) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vcdm2sdjwt_key_alias() != 49360) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vcdm2sdjwt_revealed_claims_as_json_string() != 39703) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vcdm2sdjwt_status() != 25845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vcdm2sdjwt_type() != 50079) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_add() != 42040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_all_entries() != 7074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_all_entries_by_type() != 232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_delete() != 63691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_dump() != 37372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_vdccollection_get() != 1085) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_walletserviceclient_get_auth_header() != 17536) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_walletserviceclient_get_client_id() != 13815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_walletserviceclient_get_token() != 48766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_walletserviceclient_is_token_valid() != 60518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_walletserviceclient_login() != 17740) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_walletserviceclient_nonce() != 12116) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_cryptocurveutils_secp256r1() != 20735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_cwt_new_from_base10() != 28565) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_delegatedverifier_new_client() != 15415) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_didmethodutils_new() != 22235) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_holder_new() != 64916) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_holder_new_with_credentials() != 28515) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_ihttpclient_new_async() != 55307) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_ihttpclient_new_sync() != 47576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_issuanceserviceclient_new() != 39224) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_jsonldpresentationbuilder_new() != 15501) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_jsonvc_new_from_json() != 40674) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_jsonvc_new_from_json_with_key() != 63463) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_jwtvc_new_from_compact_jws() != 5193) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_jwtvc_new_from_compact_jws_with_key() != 27338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_mdoc_from_cbor_encoded_document() != 32979) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_mdoc_from_stringified_document() != 58042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_mdoc_new_from_base64url_encoded_issuer_signed() != 17520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vp180137_new() != 4916) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new() != 27200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new_with_async_client() != 57260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new_with_default_async_client() != 51040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new_with_default_sync_client() != 30492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_oid4vci_new_with_sync_client() != 31928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_cwt() != 43883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_from_json() != 1837) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_from_string_with_format() != 6623) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_jwt_vc_json() != 56340) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_jwt_vc_json_ld() != 46832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_ldp_vc() != 45177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_mso_mdoc() != 58058) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_new_sd_jwt() != 34266) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_parsedcredential_parse_from_credential() != 15018) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_vcdm2sdjwt_new_from_compact_sd_jwt() != 56155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_vcdm2sdjwt_new_from_compact_sd_jwt_with_key() != 15244) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_vdccollection_new() != 31236) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_constructor_walletserviceclient_new() != 5221) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentationsigner_sign() != 27180) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentationsigner_algorithm() != 48923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentationsigner_verification_method() != 21787) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentationsigner_did() != 14569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentationsigner_cryptosuite() != 63070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mobile_sdk_rs_checksum_method_presentationsigner_jwk() != 12828) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitAsyncHttpClient()
    uniffiCallbackInitCrypto()
    uniffiCallbackInitKeyStore()
    uniffiCallbackInitLogWriter()
    uniffiCallbackInitSigningKey()
    uniffiCallbackInitStorageManagerInterface()
    uniffiCallbackInitSyncHttpClient()
    uniffiCallbackInitPresentationSigner()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureMobileSdkRsInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all